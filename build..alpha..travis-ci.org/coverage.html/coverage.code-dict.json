{"/home/travis/build/npmtest/node-npmtest-tsd/test.js":"/* istanbul instrument in package npmtest_tsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tsd/lib.npmtest_tsd.js":"/* istanbul instrument in package npmtest_tsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tsd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tsd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tsd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tsd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tsd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tsd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tsd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_tsd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tsd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_tsd.__dirname + '/lib.npmtest_tsd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/api.js":"'use strict';\nvar bootstrap = require('./bootstrap');\nvar API = require('./tsd/API');\nvar assertVar = require('./xm/assertVar');\nexports.Def = require('./tsd/data/Def');\nexports.Context = require('./tsd/context/Context');\nexports.Options = require('./tsd/Options');\nexports.Query = require('./tsd/select/Query');\nexports.CommitMatcher = require('./tsd/select/CommitMatcher');\nexports.DateMatcher = require('./tsd/select/DateMatcher');\nexports.InfoMatcher = require('./tsd/select/InfoMatcher');\nexports.VersionMatcher = require('./tsd/select/VersionMatcher');\nexports.defUtil = require('./tsd/util/defUtil');\nexports.getContent = require('./getContent');\nfunction getAPI(configPath, verbose) {\n    if (verbose === void 0) { verbose = false; }\n    assertVar(configPath, 'string', 'configPath');\n    return new API(new exports.Context(configPath, verbose));\n}\nexports.getAPI = getAPI;\n[\n    bootstrap,\n    exports.getContent,\n    exports.Def,\n    exports.Options,\n    exports.Query,\n    exports.Context,\n    exports.CommitMatcher,\n    exports.DateMatcher,\n    exports.InfoMatcher,\n    exports.VersionMatcher,\n    exports.defUtil\n];\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/bootstrap.js":"'use strict';\nvar Promise = require('bluebird');\nPromise.onPossiblyUnhandledRejection(function (error) {\n    console.log('---');\n    console.log(error.message);\n    throw error;\n});\ntry {\n    require('source-map-support').install();\n    Promise.longStackTraces();\n}\ncatch (e) {\n}\nprocess.setMaxListeners(20);\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/API.js":"'use strict';\nrequire('../bootstrap');\nvar path = require('path');\nvar Promise = require('bluebird');\nvar openInApp = require('open');\nvar assertVar = require('../xm/assertVar');\nvar Context = require('./context/Context');\nvar Def = require('./data/Def');\nvar defUtil = require('./util/defUtil');\nvar Query = require('./select/Query');\nvar Selection = require('./select/Selection');\nvar VersionMatcher = require('./select/VersionMatcher');\nvar InstallResult = require('./logic/InstallResult');\nvar Options = require('./Options');\nvar Core = require('./logic/Core');\nvar PackageLinker = require('./support/PackageLinker');\nvar BundleManager = require('./support/BundleManager');\nvar API = (function () {\n    function API(context) {\n        this.context = context;\n        assertVar(context, Context, 'context');\n        this.core = new Core(this.context);\n    }\n    API.prototype.initConfig = function (overwrite) {\n        var _this = this;\n        return this.core.config.initConfig(overwrite).then(function (configPath) {\n            configPath = path.relative(process.cwd(), configPath);\n            if (!_this.context.config.bundle) {\n                return Promise.resolve([configPath]);\n            }\n            var manager = new BundleManager(_this.core.context.getTypingsDir());\n            return manager.saveEmptyBundle(_this.context.config.bundle).then(function () {\n                return [configPath, path.relative(process.cwd(), _this.context.config.bundle)];\n            }, function () {\n                return [configPath];\n            });\n        });\n    };\n    API.prototype.readConfig = function (optional) {\n        return this.core.config.readConfig(optional);\n    };\n    API.prototype.saveConfig = function () {\n        return this.core.config.saveConfig();\n    };\n    API.prototype.select = function (query, options) {\n        assertVar(query, Query, 'query');\n        assertVar(options, Options, 'options', true);\n        options = options || Options.main;\n        return this.core.selector.select(query, options);\n    };\n    API.prototype.install = function (selection, options) {\n        var _this = this;\n        assertVar(selection, Selection, 'selection');\n        assertVar(options, Options, 'options', true);\n        options = options || Options.main;\n        var res = new InstallResult(options);\n        var files = defUtil.mergeDependencies(selection.selection);\n        return this.core.installer.installFileBulk(files, options.saveToConfig, options.overwriteFiles)\n            .then(function (written) {\n            if (!written) {\n                throw new Error('expected install paths');\n            }\n            res.written = written;\n        }).then(function () {\n            if (options.saveToConfig) {\n                return _this.core.config.saveConfig();\n            }\n            return null;\n        }).then(function () {\n            return _this.saveBundles(res.written.values(), options);\n        }).return(res);\n    };\n    API.prototype.saveBundles = function (files, options) {\n        assertVar(files, 'array', 'files');\n        assertVar(options, Options, 'options', true);\n        options = options || Options.main;\n        if (files.length === 0) {\n            return Promise.resolve();\n        }\n        var refs = [];\n        files.forEach(function (file) {\n            refs.push(file.def.path);\n        });\n        refs.sort();\n        var basePath = path.dirname(this.context.paths.configFile);\n        var manager = new BundleManager(this.core.context.getTypingsDir());\n        var bundles = [];\n        if (options.addToBundles) {\n            options.addToBundles.forEach(function (bundle) {\n                bundle = path.resolve(basePath, bundle);\n                if (!/\\.ts$/.test(bundle)) {\n                    bundle += '.d.ts';\n                }\n                bundles.push(bundle);\n            });\n        }\n        if ((options.saveToConfig || options.saveBundle) && this.context.config.bundle) {\n            bundles.push(path.resolve(basePath, this.context.config.bundle));\n        }\n        return Promise.map(bundles, function (target) {\n            return manager.addToBundle(target, refs, true);\n        }).return();\n    };\n    API.prototype.reinstall = function (options) {\n        var _this = this;\n        var res = new InstallResult(options);\n        return this.core.installer.reinstallBulk(this.context.config.getInstalled(), options.overwriteFiles)\n            .then(function (map) {\n            res.written = map;\n        }).then(function () {\n            if (options.saveToConfig) {\n                return _this.core.config.saveConfig();\n            }\n            return null;\n        }).then(function () {\n            return _this.saveBundles(res.written.values(), options);\n        }).then(function () {\n            if (options.reinstallClean) {\n                var typingsPath = path.join(path.dirname(_this.core.context.paths.configFile), _this.core.context.config.toJSON().path);\n                _this.core.installer.removeUnusedReferences(_this.context.config.getInstalled(), typingsPath).then(function (removedList) {\n                    options.overwriteFiles = options.saveBundle = true;\n                    return _this.saveBundles(_this.context.config.getInstalledAsDefVersionList(), options);\n                });\n            }\n            else {\n                options.overwriteFiles = options.saveBundle = true;\n                return _this.saveBundles(_this.context.config.getInstalledAsDefVersionList(), options);\n            }\n            return null;\n        }).return(res);\n    };\n    API.prototype.update = function (options, version) {\n        var _this = this;\n        if (version === void 0) { version = 'latest'; }\n        var query = new Query();\n        this.context.config.getInstalled().forEach(function (inst) {\n            query.addNamePattern(new Def(inst.path).pathTerm);\n        });\n        query.versionMatcher = new VersionMatcher(version);\n        return this.select(query, options).then(function (selection) {\n            return _this.install(selection, options);\n        });\n    };\n    API.prototype.link = function (baseDir) {\n        assertVar(baseDir, 'string', 'baseDir');\n        var linker = new PackageLinker();\n        var manager = new BundleManager(this.core.context.getTypingsDir());\n        var bundlePath = path.join(path.dirname(this.core.context.paths.configFile), this.core.context.config.toJSON().bundle);\n        return linker.scanDefinitions(baseDir).then(function (packages) {\n            return Promise.reduce(packages, function (memo, packaged) {\n                return manager.addToBundle(bundlePath, packaged.definitions, true).then(function (change) {\n                    if (change.someAdded()) {\n                        memo.push(packaged);\n                    }\n                    return memo;\n                });\n            }, []);\n        });\n    };\n    API.prototype.addToBundle = function (target, refs, save) {\n        var manager = new BundleManager(this.core.context.getTypingsDir());\n        return manager.addToBundle(target, refs, save);\n    };\n    API.prototype.cleanupBundle = function (target, save) {\n        var manager = new BundleManager(this.core.context.getTypingsDir());\n        return manager.cleanupBundle(target, save);\n    };\n    API.prototype.updateBundle = function (target, save) {\n        var manager = new BundleManager(this.core.context.getTypingsDir());\n        return manager.updateBundle(target, save);\n    };\n    API.prototype.getRateInfo = function () {\n        return this.core.repo.api.getRateInfo();\n    };\n    API.prototype.compare = function (query) {\n        assertVar(query, Query, 'query');\n        return Promise.reject(new Error('not implemented yet'));\n    };\n    API.prototype.browse = function (list) {\n        var _this = this;\n        assertVar(list, 'array', 'list');\n        if (list.length > 2) {\n            return Promise.reject(new Error('to many results to open in browser'));\n        }\n        return Promise.resolve(list.map(function (file) {\n            var ref = file.commit.commitSha;\n            if (file.def.head && file.commit.commitSha === file.def.head.commit.commitSha) {\n                ref = _this.core.context.config.ref;\n            }\n            var url = _this.core.repo.urls.htmlFile(ref, file.def.path);\n            openInApp(url);\n            return url;\n        }));\n    };\n    API.prototype.visit = function (list) {\n        var _this = this;\n        assertVar(list, 'array', 'list');\n        if (list.length > 2) {\n            return Promise.reject(new Error('to many results to open in browser'));\n        }\n        return Promise.map(list, function (file) {\n            if (!file.info) {\n                return _this.core.parser.parseDefInfo(file);\n            }\n            return Promise.resolve(file);\n        }).then(function (list) {\n            return list.reduce(function (memo, file) {\n                var urls;\n                if (file.info && file.info.projects) {\n                    urls = file.info.projects;\n                }\n                else if (file.def.head.info && file.def.head.info.projects) {\n                    urls = file.def.head.info.projects;\n                }\n                if (urls) {\n                    urls.forEach(function (url) {\n                        memo.push(url);\n                        openInApp(url);\n                    });\n                }\n                return memo;\n            }, []);\n        });\n    };\n    API.prototype.purge = function (raw, api) {\n        var queue = [];\n        if (raw) {\n            queue.push(this.core.repo.raw.cache.cleanupCacheAge(0));\n        }\n        if (api) {\n            queue.push(this.core.repo.api.cache.cleanupCacheAge(0));\n        }\n        return Promise.all(queue).return();\n    };\n    return API;\n})();\nmodule.exports = API;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/assertVar.js":"'use strict';\nvar AssertionError = require('assertion-error');\nvar typeOf = require('./typeOf');\nvar inspect = require('./inspect');\nvar encode = require('./encode');\nvar typeOfAssert = typeOf.getTypeOfMap();\nfunction assertVar(value, type, label, opt) {\n    if (opt === void 0) { opt = false; }\n    if (arguments.length < 3) {\n        throw new AssertionError('expected at least 3 arguments but got \"' + arguments.length + '\"');\n    }\n    var valueKind = typeOf.get(value);\n    var typeKind = typeOf.get(type);\n    if (!typeOf.isValid(value)) {\n        if (!opt) {\n            throw new AssertionError('expected ' + encode.wrapQuotes(label, true)\n                + ' to be defined as a ' + inspect.toValueStrim(type)\n                + ' but got ' + (valueKind === 'number' ? 'NaN' : valueKind), undefined, assertVar);\n        }\n    }\n    else if (typeKind === 'function') {\n        if (!(value instanceof type)) {\n            throw new AssertionError('expected ' + encode.wrapQuotes(label, true)\n                + ' to be instanceof ' + inspect.getFuncLabel(type)\n                + ' but is a ' + inspect.getFuncLabel(value.constructor)\n                + ': ' + inspect.toValueStrim(value), undefined, assertVar);\n        }\n    }\n    else if (typeKind === 'string') {\n        if (typeOf.hasOwnProp(typeOfAssert, type)) {\n            var check = typeOfAssert[type];\n            if (!check(value)) {\n                throw new AssertionError('expected ' + encode.wrapQuotes(label, true)\n                    + ' to be a ' + encode.wrapQuotes(type, true)\n                    + ' but got a ' + encode.wrapQuotes(valueKind, true)\n                    + ': ' + inspect.toValueStrim(value), undefined, assertVar);\n            }\n        }\n        else {\n            throw new AssertionError('unknown type-assertion parameter ' + encode.wrapQuotes(type, true)\n                + ' for ' + inspect.toValueStrim(value), undefined, assertVar);\n        }\n    }\n    else {\n        throw new AssertionError('bad type-assertion parameter '\n            + inspect.toValueStrim(type)\n            + ' for '\n            + encode.wrapQuotes(label, true), undefined, assertVar);\n    }\n}\nmodule.exports = assertVar;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/typeOf.js":"'use strict';\nvar typeDetect = require('type-detect');\nvar toString = Object.prototype.toString;\nfunction get(value) {\n    return typeDetect(value);\n}\nexports.get = get;\nexports.jsonTypes = [\n    'array',\n    'object',\n    'boolean',\n    'number',\n    'string',\n    'null'\n];\nexports.primitiveTypes = [\n    'boolean',\n    'number',\n    'string'\n];\nexports.valueTypes = [\n    'boolean',\n    'number',\n    'string',\n    'null'\n];\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProp(value, prop) {\n    return hasOwnProperty.call(value, prop);\n}\nexports.hasOwnProp = hasOwnProp;\nfunction isType(value, type) {\n    if (hasOwnProp(exports.typeMap, type)) {\n        return exports.typeMap[type].call(null, value);\n    }\n    return false;\n}\nexports.isType = isType;\nfunction isArguments(value) {\n    return typeDetect(value) === 'arguments';\n}\nexports.isArguments = isArguments;\nfunction isArray(value) {\n    return typeDetect(value) === 'array';\n}\nexports.isArray = isArray;\nfunction isDate(value) {\n    return typeDetect(value) === 'date';\n}\nexports.isDate = isDate;\nfunction isFunction(value) {\n    return typeDetect(value) === 'function';\n}\nexports.isFunction = isFunction;\nfunction isNumber(value) {\n    return typeDetect(value) === 'number';\n}\nexports.isNumber = isNumber;\nfunction isRegExp(value) {\n    return typeDetect(value) === 'regexp';\n}\nexports.isRegExp = isRegExp;\nfunction isString(value) {\n    return typeDetect(value) === 'string';\n}\nexports.isString = isString;\nfunction isNull(value) {\n    return typeDetect(value) === 'null';\n}\nexports.isNull = isNull;\nfunction isUndefined(value) {\n    return typeDetect(value) === 'undefined';\n}\nexports.isUndefined = isUndefined;\nfunction isObject(value) {\n    return typeDetect(value) === 'object';\n}\nexports.isObject = isObject;\nfunction isBoolean(value) {\n    return typeDetect(value) === 'boolean';\n}\nexports.isBoolean = isBoolean;\nfunction isArrayLike(value) {\n    return (typeDetect(value) === 'array' || typeDetect(value) === 'arguments');\n}\nexports.isArrayLike = isArrayLike;\nfunction isOk(value) {\n    return !!value;\n}\nexports.isOk = isOk;\nfunction isFlagOn(value) {\n    if (!isValid(value)) {\n        return false;\n    }\n    value = String(value).trim().toLowerCase();\n    if (value === '' || value === '0') {\n        return false;\n    }\n    switch (value) {\n        case 'false':\n        case 'null':\n        case 'nan':\n        case 'undefined':\n        case 'no':\n        case 'off':\n        case 'disabled':\n            return false;\n    }\n    return true;\n}\nexports.isFlagOn = isFlagOn;\nfunction isValid(value) {\n    var type = typeDetect(value);\n    return !(type === 'undefined' || type === 'null' || (type === 'number' && isNaN(value)));\n}\nexports.isValid = isValid;\nfunction isNaN(value) {\n    return value !== value;\n}\nexports.isNaN = isNaN;\nfunction isJSONValue(value) {\n    return exports.jsonTypes.indexOf(typeDetect(value)) > -1;\n}\nexports.isJSONValue = isJSONValue;\nfunction isPrimitive(value) {\n    return exports.primitiveTypes.indexOf(typeDetect(value)) > -1;\n}\nexports.isPrimitive = isPrimitive;\nfunction isValueType(value) {\n    return exports.valueTypes.indexOf(typeDetect(value)) > -1;\n}\nexports.isValueType = isValueType;\nfunction isSha(value) {\n    if (typeof value !== 'string') {\n        return false;\n    }\n    return /^[0-9a-f]{40}$/.test(value);\n}\nexports.isSha = isSha;\nfunction isShaShort(value) {\n    if (typeof value !== 'string') {\n        return false;\n    }\n    return /^[0-9a-f]{6,40}$/.test(value);\n}\nexports.isShaShort = isShaShort;\nfunction isMd5(value) {\n    if (typeof value !== 'string') {\n        return false;\n    }\n    return /^[0-9a-f]{32}$/.test(value);\n}\nexports.isMd5 = isMd5;\nexports.typeMap = {\n    arguments: isArguments,\n    array: isArray,\n    date: isDate,\n    function: isFunction,\n    number: isNumber,\n    regexp: isRegExp,\n    string: isString,\n    null: isNull,\n    undefined: isUndefined,\n    object: isObject,\n    boolean: isBoolean,\n    ok: isOk,\n    valid: isValid,\n    sha1: isSha,\n    md5: isMd5,\n    jsonValue: isJSONValue\n};\nfunction getTypeOfMap(add) {\n    var name;\n    var value = Object.create(null);\n    for (name in exports.typeMap) {\n        if (hasOwnProp(exports.typeMap, name)) {\n            if (!isFunction(exports.typeMap[name])) {\n                throw new Error('bad typeOf function ' + name);\n            }\n            value[name] = exports.typeMap[name];\n        }\n    }\n    if (add) {\n        for (name in add) {\n            if (hasOwnProp(add, name) && isFunction(add[name])) {\n                value[name] = add[name];\n            }\n        }\n    }\n    return value;\n}\nexports.getTypeOfMap = getTypeOfMap;\nfunction getTypeOfWrap(add) {\n    var typeMap = getTypeOfMap(add);\n    return function isTypeWrap(value, type) {\n        if (hasOwnProp(typeMap, type)) {\n            return typeMap[type].call(null, value);\n        }\n        return false;\n    };\n}\nexports.getTypeOfWrap = getTypeOfWrap;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/inspect.js":"'use strict';\nvar typeDetect = require('type-detect');\nvar encode = require('./encode');\nfunction getFuncLabel(func) {\n    var match = /^\\s?function ([^( ]*) *\\( *([^(]*?) *\\)/.exec(String(func));\n    if (match && match.length >= 3) {\n        return match[1] + '(' + match[2] + ')';\n    }\n    if (func.name) {\n        return func.name;\n    }\n    return '<anonymous>';\n}\nexports.getFuncLabel = getFuncLabel;\nfunction toValueStrim(obj, depth, cutoff) {\n    if (depth === void 0) { depth = 4; }\n    if (cutoff === void 0) { cutoff = 80; }\n    var type = typeDetect(obj);\n    depth--;\n    switch (type) {\n        case 'boolean':\n        case 'regexp':\n            return obj.toString();\n        case 'null':\n        case 'undefined':\n            return type;\n        case 'number':\n            return obj.toString(10);\n        case 'string':\n            return encode.trimWrap(obj, cutoff, true);\n        case 'date':\n            return obj.toISOString();\n        case 'function':\n            return getFuncLabel(obj);\n        case 'arguments':\n        case 'array':\n            {\n                if (depth <= 0) {\n                    return '<maximum recursion>';\n                }\n                return '[' + encode.trim(obj.map(function (value) {\n                    return encode.trim(value, depth);\n                }).join(','), cutoff) + ']';\n            }\n        case 'object':\n            {\n                if (depth <= 0) {\n                    return '<maximum recursion>';\n                }\n                return encode.trim(String(obj) + ' {' + Object.keys(obj).sort().map(function (key) {\n                    return encode.trim(key) + ':' + toValueStrim(obj[key], depth);\n                }).join(','), cutoff) + '}';\n            }\n        default:\n            throw (new Error('toValueStrim: cannot serialise type: ' + type));\n    }\n}\nexports.toValueStrim = toValueStrim;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/encode.js":"'use strict';\nvar typeOf = require('./typeOf');\nvar stringExp = /^[a-z](?:[a-z0-9_\\-]*?[a-z0-9])?$/i;\nvar stringQuote = '\"';\nvar identExp = /^[a-z](?:[a-z0-9_\\-]*?[a-z0-9])?$/i;\nvar identAnyExp = /^[a-z0-9](?:[a-z0-9_\\-]*?[a-z0-9])?$/i;\nvar intExp = /^\\d+$/;\nvar escapeRep = '\\\\$&';\nvar escapeAdd = '\\\\$&$&';\nexports.singleQuoteExp = /([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'/g;\nexports.doubleQuoteExp = /([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"/g;\nfunction getEscaper(vars) {\n    var values = (typeOf.isString(vars.values) ? vars.values.split('') : vars.values);\n    var matches = (typeOf.isString(vars.matches) ? vars.matches.split('') : vars.matches);\n    var replacer = function (match) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var i = matches.indexOf(match);\n        if (i > -1 && i < values.length) {\n            return '\\\\' + values[i];\n        }\n        return match;\n    };\n    var exp = new RegExp('[' + values.map(function (char) {\n        return '\\\\' + char;\n    }).join('') + ']', 'g');\n    return function (input) {\n        return input.replace(exp, replacer);\n    };\n}\nexports.getEscaper = getEscaper;\nfunction getMultiReplacer(vars) {\n    var values = vars.values;\n    var matches = vars.matches;\n    var replacer = function (match) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var i = matches.indexOf(match);\n        if (i > -1 && i < values.length) {\n            return values[i];\n        }\n        return match;\n    };\n    var exp = new RegExp(vars.exps.map(function (char) {\n        return '(?:' + char + ')';\n    }).join('|'), 'g');\n    return function (input) {\n        return input.replace(exp, replacer);\n    };\n}\nexports.getMultiReplacer = getMultiReplacer;\nexports.unprintCC = getEscaper({\n    matches: '\\b\\f\\n\\r\\t\\v\\0',\n    values: 'bfnrtv0'\n});\nexports.unprintNL = getEscaper({\n    matches: '\\r\\n',\n    values: 'rn'\n});\nexports.unprintNotNL = getEscaper({\n    matches: '\\b\\f\\t\\v\\0',\n    values: 'bftv0'\n});\nexports.unprintNLS = getMultiReplacer({\n    exps: ['\\\\r\\\\n', '\\\\n', '\\\\r'],\n    matches: ['\\r\\n', '\\n', '\\r'],\n    values: ['\\\\r\\\\n\\r\\n', '\\\\n\\n', '\\\\r\\r']\n});\nfunction quoteSingle(input) {\n    return input.replace(exports.singleQuoteExp, '$1\\\\\\'');\n}\nexports.quoteSingle = quoteSingle;\nfunction quoteDouble(input) {\n    return input.replace(exports.doubleQuoteExp, '$1\\\\\"');\n}\nexports.quoteDouble = quoteDouble;\nfunction quoteSingleWrap(input) {\n    return '\\'' + input.replace(exports.singleQuoteExp, '$1\\\\\\'') + '\\'';\n}\nexports.quoteSingleWrap = quoteSingleWrap;\nfunction quoteDoubleWrap(input) {\n    return '\"' + input.replace(exports.doubleQuoteExp, '$1\\\\\"') + '\"';\n}\nexports.quoteDoubleWrap = quoteDoubleWrap;\nfunction escapeControl(input, reAddNewlines) {\n    if (reAddNewlines === void 0) { reAddNewlines = false; }\n    input = String(input);\n    if (reAddNewlines) {\n        return exports.unprintNLS(exports.unprintNotNL(input));\n    }\n    return exports.unprintCC(input);\n}\nexports.escapeControl = escapeControl;\nfunction wrapQuotes(input, double) {\n    input = escapeControl(input);\n    if (double) {\n        return quoteDoubleWrap(input);\n    }\n    return quoteSingleWrap(input);\n}\nexports.wrapQuotes = wrapQuotes;\nfunction wrapIfComplex(input, double) {\n    input = String(input);\n    if (!identAnyExp.test(input)) {\n        return wrapQuotes(exports.unprintCC(input), double);\n    }\n    return input;\n}\nexports.wrapIfComplex = wrapIfComplex;\nfunction trim(value, cutoff) {\n    if (cutoff === void 0) { cutoff = 60; }\n    if (cutoff && value.length > cutoff) {\n        return value.substr(0, cutoff) + '...';\n    }\n    return value;\n}\nexports.trim = trim;\nfunction trimWrap(value, cutoff, double) {\n    if (cutoff === void 0) { cutoff = 60; }\n    value = String(value);\n    if (cutoff && value.length > cutoff) {\n        return wrapQuotes(value.substr(0, cutoff), double) + '...';\n    }\n    return wrapQuotes(value, double);\n}\nexports.trimWrap = trimWrap;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/context/Context.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\nvar assertVar = require('../../xm/assertVar');\nvar fileIO = require('../../xm/fileIO');\nvar JSONPointer = require('../../xm/lib/JSONPointer');\nvar PackageJSON = require('../../xm/lib/PackageJSON');\nvar Config = require('./Config');\nvar Paths = require('./Paths');\nvar Const = require('./Const');\nvar Context = (function () {\n    function Context(configFile, verbose) {\n        if (configFile === void 0) { configFile = null; }\n        if (verbose === void 0) { verbose = false; }\n        assertVar(configFile, 'string', 'configFile', true);\n        assertVar(verbose, 'boolean', 'verbose');\n        this.packageInfo = PackageJSON.getLocal();\n        this.settings = new JSONPointer(fileIO.readJSONSync(path.resolve(path.dirname(PackageJSON.find()), 'conf', 'settings.json')));\n        this.stackSettings(path.resolve(Paths.getUserHome(), Const.rc));\n        this.stackSettings(path.resolve(process.cwd(), Const.rc));\n        this.verbose = verbose;\n        this.paths = new Paths();\n        if (configFile) {\n            this.paths.configFile = path.resolve(configFile);\n        }\n        this.paths.cacheDir = Paths.getUserCacheDir();\n        this.config = new Config();\n    }\n    Context.prototype.stackSettings = function (src) {\n        if (fs.existsSync(src)) {\n            if (this.verbose) {\n                console.log('using rc: ' + src);\n            }\n            this.settings.addSource(fileIO.readJSONSync(src));\n        }\n        else {\n            if (this.verbose) {\n                console.log('cannot find rc: ' + src);\n            }\n        }\n    };\n    Context.prototype.getTypingsDir = function () {\n        return this.config.resolveTypingsPath(path.dirname(this.paths.configFile));\n    };\n    Context.prototype.getInfo = function (details) {\n        if (details === void 0) { details = false; }\n        var info = {\n            version: this.packageInfo.getNameVersion(),\n            repo: 'https://github.com/' + this.config.repo + ' #' + this.config.ref\n        };\n        if (details) {\n            info.paths = this.paths;\n            info.typings = this.config.resolveTypingsPath(path.dirname(this.paths.configFile));\n            info.config = this.config.toJSON();\n        }\n        return info;\n    };\n    return Context;\n})();\nmodule.exports = Context;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/fileIO.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\nvar globMod = require('glob');\nvar VError = require('verror');\nvar Promise = require('bluebird');\nvar mkdirp = require('mkdirp');\nvar rimrafMod = require('rimraf');\nvar mkdirpP = Promise.promisify(mkdirp);\nfunction distributeDir(base, name, levels, chunk) {\n    if (chunk === void 0) { chunk = 1; }\n    name = name.replace(/(^[\\\\\\/]+)|([\\\\\\/]+$)/g, '');\n    if (levels === 0) {\n        return base;\n    }\n    if (chunk === 0) {\n        return base;\n    }\n    var arr = [base];\n    var steps = Math.max(0, Math.min(name.length - 2, levels * chunk));\n    for (var i = 0; i < steps; i += chunk) {\n        arr.push(name.substr(i, chunk));\n    }\n    return path.join.apply(path, arr);\n}\nexports.distributeDir = distributeDir;\nfunction parseJson(text) {\n    var json;\n    try {\n        json = JSON.parse(text);\n    }\n    catch (err) {\n        if (err.name === 'SyntaxError') {\n        }\n        throw (err);\n    }\n    return json;\n}\nexports.parseJson = parseJson;\nfunction readJSONSync(src) {\n    return parseJson(String(fs.readFileSync(src, { encoding: 'utf8' })));\n}\nexports.readJSONSync = readJSONSync;\nfunction readJSONCB(src, callback) {\n    fs.readFile(path.resolve(src), { encoding: 'utf8' }, function (err, text) {\n        if (err || typeof text !== 'string') {\n            return callback(err, null);\n        }\n        var json = null;\n        try {\n            json = parseJson(text);\n        }\n        catch (err) {\n            return callback(err, null);\n        }\n        return callback(null, json);\n    });\n}\nexports.readJSONCB = readJSONCB;\nfunction readJSON(src) {\n    return read(src, { encoding: 'utf8' }).then(function (text) {\n        return parseJson(text);\n    });\n}\nexports.readJSON = readJSON;\nfunction writeJSONSync(dest, data) {\n    dest = path.resolve(dest);\n    mkdirCheckSync(path.dirname(dest));\n    fs.writeFileSync(dest, JSON.stringify(data, null, 2), { encoding: 'utf8' });\n}\nexports.writeJSONSync = writeJSONSync;\nfunction writeJSON(filename, data) {\n    return write(filename, JSON.stringify(data, null, 2), { encoding: 'utf8' });\n}\nexports.writeJSON = writeJSON;\nfunction readFileSync(dest, encoding) {\n    if (encoding === void 0) { encoding = 'utf8'; }\n    return fs.readFileSync(dest, { encoding: encoding });\n}\nexports.readFileSync = readFileSync;\nfunction writeFileSync(dest, data, encoding) {\n    if (encoding === void 0) { encoding = 'utf8'; }\n    dest = path.resolve(dest);\n    mkdirCheckSync(path.dirname(dest), true);\n    fs.writeFileSync(dest, data, { encoding: encoding });\n}\nexports.writeFileSync = writeFileSync;\nfunction mkdirCheckSync(dir, writable) {\n    if (writable === void 0) { writable = false; }\n    dir = path.resolve(dir);\n    if (fs.existsSync(dir)) {\n        if (!fs.statSync(dir).isDirectory()) {\n            throw new Error('path exists but is not a directory ' + dir);\n        }\n        if (writable) {\n            fs.chmodSync(dir, '744');\n        }\n    }\n    else {\n        if (writable) {\n            mkdirp.sync(dir, '744');\n        }\n        else {\n            mkdirp.sync(dir);\n        }\n    }\n    return dir;\n}\nexports.mkdirCheckSync = mkdirCheckSync;\nfunction mkdirCheck(dir, writable) {\n    if (writable === void 0) { writable = false; }\n    dir = path.resolve(dir);\n    return exists(dir).then(function (exists) {\n        if (exists) {\n            return isDirectory(dir).then(function (isDir) {\n                if (!isDir) {\n                    throw (new Error('path exists but is not a directory ' + dir));\n                }\n                if (writable) {\n                    return chmod(dir, '744');\n                }\n            });\n        }\n        else if (writable) {\n            return mkdirpP(dir, '744');\n        }\n        else {\n            return mkdirpP(dir);\n        }\n    }).return(dir);\n}\nexports.mkdirCheck = mkdirCheck;\nfunction canWriteFile(targetPath, overwrite) {\n    return exists(targetPath).then(function (exists) {\n        if (!exists) {\n            return Promise.resolve(true);\n        }\n        return isFile(targetPath).then(function (isFile) {\n            if (isFile) {\n                return overwrite;\n            }\n            return false;\n        });\n    });\n}\nexports.canWriteFile = canWriteFile;\nfunction removeFile(target) {\n    return exists(target).then(function (exists) {\n        if (!exists) {\n            return;\n        }\n        return isFile(target).then(function (isFile) {\n            if (!isFile) {\n                throw new Error('not a file ' + target);\n            }\n            return remove(target);\n        });\n    });\n}\nexports.removeFile = removeFile;\nfunction removeAllFilesFromDir(target) {\n    if (!fs.existsSync(target)) {\n        return;\n    }\n    var files = fs.readdirSync(target);\n    files.forEach(function (file) {\n        if (fs.statSync(path.join(target, file)).isFile()) {\n            fs.unlinkSync(path.join(target, file));\n        }\n    });\n}\nexports.removeAllFilesFromDir = removeAllFilesFromDir;\nfunction getDirNameList(target) {\n    var list = [];\n    if (fs.existsSync(target)) {\n        fs.readdirSync(target).forEach(function (file, index) {\n            if (fs.statSync(path.join(target, file)).isDirectory()) {\n                list.push(file);\n            }\n        });\n    }\n    return list;\n}\nexports.getDirNameList = getDirNameList;\nfunction removeDirSync(target) {\n    syncDeleteFolderRecursive(target);\n}\nexports.removeDirSync = removeDirSync;\nfunction rimraf(target) {\n    return new Promise(function (resolve, reject) {\n        rimrafMod(target, function (err) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(undefined);\n            }\n        });\n    });\n}\nexports.rimraf = rimraf;\nvar utimes = Promise.promisify(fs.utimes);\nfunction touchFile(src, atime, mtime) {\n    return stat(src).then(function (stat) {\n        atime = (atime || new Date());\n        mtime = (mtime || stat.mtime);\n        return utimes(src, atime, mtime);\n    }).return();\n}\nexports.touchFile = touchFile;\nfunction findup(dir, name) {\n    return Promise.attempt(function () {\n        if (dir === '/') {\n            throw new Error('could not find package.json up from ' + dir);\n        }\n        else if (!dir || dir === '.') {\n            throw new Error('cannot find package.json from unspecified directory');\n        }\n        var file = path.join(dir, name);\n        return exists(file).then(function (exists) {\n            if (exists) {\n                return Promise.resolve(file);\n            }\n            var dirName = path.dirname(dir);\n            if (dirName === dir) {\n                throw new Error('cannot find file ' + name);\n            }\n            return findup(path.dirname(dir), name).then(function (file) {\n                return file;\n            });\n        });\n    });\n}\nexports.findup = findup;\nfunction exists(filename) {\n    return new Promise(function (resolve) {\n        fs.exists(filename, resolve);\n    }).catch(function () {\n        return false;\n    });\n}\nexports.exists = exists;\nfunction stat(filename) {\n    return new Promise(function (resolve, reject) {\n        fs.stat(filename, function (err, stat) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(stat);\n            }\n        });\n    });\n}\nexports.stat = stat;\nfunction isFile(filename) {\n    return stat(filename).then(function (stat) {\n        return stat.isFile();\n    }).catch(function (e) {\n        return false;\n    });\n}\nexports.isFile = isFile;\nfunction isDirectory(filename) {\n    return stat(filename).then(function (stat) {\n        return stat.isDirectory();\n    }).catch(function (e) {\n        return false;\n    });\n}\nexports.isDirectory = isDirectory;\nfunction read(filename, opts) {\n    return new Promise(function (resolve, reject) {\n        fs.readFile(filename, opts, function (err, content) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(content);\n            }\n        });\n    });\n}\nexports.read = read;\nfunction write(filename, content, opts) {\n    filename = path.resolve(filename);\n    return mkdirCheck(path.dirname(filename), true).then(function () {\n        return new Promise(function (resolve, reject) {\n            fs.writeFile(filename, content, opts, function (err) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n        });\n    });\n}\nexports.write = write;\nfunction remove(filename) {\n    return new Promise(function (resolve, reject) {\n        fs.unlink(filename, function (err) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(undefined);\n            }\n        });\n    });\n}\nexports.remove = remove;\nfunction syncDeleteFolderRecursive(path) {\n    if (fs.existsSync(path)) {\n        fs.readdirSync(path).forEach(function (file, index) {\n            var curPath = path + '/' + file;\n            if (fs.lstatSync(curPath).isDirectory()) {\n                syncDeleteFolderRecursive(curPath);\n            }\n            else {\n                fs.unlinkSync(curPath);\n            }\n        });\n        fs.rmdirSync(path);\n    }\n}\nexports.syncDeleteFolderRecursive = syncDeleteFolderRecursive;\nfunction chmod(filename, mode) {\n    return new Promise(function (resolve, reject) {\n        fs.chmod(filename, mode, function (err) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(undefined);\n            }\n        });\n    });\n}\nexports.chmod = chmod;\nfunction glob(pattern, opts) {\n    return new Promise(function (resolve, reject) {\n        globMod(pattern, (opts || {}), function (err, paths) {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(paths);\n            }\n        });\n    });\n}\nexports.glob = glob;\nfunction concat(arrays) {\n    return Array.prototype.concat.apply([], arrays);\n}\n;\nfunction readdir(basePath) {\n    return new Promise(function (resolve, reject) {\n        fs.readdir(basePath, function (error, list) {\n            if (error) {\n                return reject(new VError(error, 'Can\\'t list %s', JSON.stringify(path)));\n            }\n            else {\n                resolve(list);\n            }\n        });\n    });\n}\nexports.readdir = readdir;\nfunction listTree(basePath, guard) {\n    basePath = String(basePath || '');\n    if (!basePath) {\n        basePath = '.';\n    }\n    guard = guard || function (basePath, stat) {\n        return true;\n    };\n    return stat(basePath).then(function (stat) {\n        var paths = [];\n        var include = guard(basePath, stat);\n        if (include) {\n            paths.push([basePath]);\n        }\n        if (include !== null && stat.isDirectory()) {\n            return readdir(basePath).then(function (children) {\n                paths.push.apply(paths, children.map(function (child) {\n                    return listTree(path.join(basePath, child), guard);\n                }));\n                return paths;\n            });\n        }\n        else {\n            return Promise.resolve(paths);\n        }\n    }).catch(function (reason) {\n        return [];\n    }).then(Promise.all).then(concat);\n}\nexports.listTree = listTree;\nfunction copyFileSync(source, target) {\n    var targetFile = target;\n    if (fs.existsSync(target)) {\n        if (fs.lstatSync(target).isDirectory()) {\n            targetFile = path.join(target, path.basename(source));\n        }\n    }\n    fs.createReadStream(source).pipe(fs.createWriteStream(targetFile));\n}\nexports.copyFileSync = copyFileSync;\nfunction copyFolderRecursiveSync(source, target, inscludeSource) {\n    var files = [];\n    var targetFolder = '';\n    if (inscludeSource) {\n        targetFolder = path.resolve('..', target);\n    }\n    else {\n        targetFolder = path.join(target, path.basename(source));\n    }\n    if (!fs.existsSync(targetFolder)) {\n        fs.mkdirSync(targetFolder);\n    }\n    if (fs.lstatSync(source).isDirectory()) {\n        files = fs.readdirSync(source);\n        files.forEach(function (file) {\n            var curSource = path.join(source, file);\n            if (fs.lstatSync(curSource).isDirectory()) {\n                copyFolderRecursiveSync(curSource, targetFolder);\n            }\n            else {\n                copyFileSync(curSource, targetFolder);\n            }\n        });\n    }\n}\nexports.copyFolderRecursiveSync = copyFolderRecursiveSync;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/lib/JSONPointer.js":"'use strict';\nvar pointer = require('json-pointer');\nvar typeOf = require('../typeOf');\nvar JSONPointer = (function () {\n    function JSONPointer(object, prefix) {\n        if (prefix === void 0) { prefix = ''; }\n        this.prefix = '';\n        this.objects = object ? [object] : [];\n        if (prefix && !/^\\//.test(prefix)) {\n            prefix = '/' + prefix;\n        }\n        this.prefix = prefix;\n    }\n    JSONPointer.prototype.hasValue = function (path) {\n        if (!/^\\//.test(path)) {\n            path = '/' + path;\n        }\n        path = this.prefix + path;\n        for (var i = 0, ii = this.objects.length; i < ii; i++) {\n            if (pointer.has(this.objects[i], path)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    JSONPointer.prototype.getValue = function (path, alt) {\n        if (alt === void 0) { alt = null; }\n        if (!/^\\//.test(path)) {\n            path = '/' + path;\n        }\n        path = this.prefix + path;\n        for (var i = 0, ii = this.objects.length; i < ii; i++) {\n            var obj = this.objects[i];\n            if (pointer.has(obj, path)) {\n                return pointer.get(obj, path);\n            }\n        }\n        return alt;\n    };\n    JSONPointer.prototype.addSource = function (object) {\n        this.objects.unshift(object);\n    };\n    JSONPointer.prototype.setValue = function (path, value) {\n        if (!/^\\//.test(path)) {\n            path = '/' + path;\n        }\n        path = this.prefix + path;\n        pointer.set(this.objects[0], path, value);\n    };\n    JSONPointer.prototype.getChild = function (path, alt) {\n        if (alt === void 0) { alt = null; }\n        if (!/^\\//.test(path)) {\n            path = '/' + path;\n        }\n        if (this.hasValue(path)) {\n            var p = new JSONPointer();\n            p.objects = this.objects.slice(0);\n            p.prefix = this.prefix + path;\n            return p;\n        }\n        return alt;\n    };\n    JSONPointer.prototype.getNumber = function (path, alt) {\n        if (alt === void 0) { alt = NaN; }\n        var value = this.getValue(path);\n        if (typeof value === 'number') {\n            return value;\n        }\n        return alt;\n    };\n    JSONPointer.prototype.getBoolean = function (path, alt) {\n        if (alt === void 0) { alt = false; }\n        return typeOf.isFlagOn(this.getValue(path, alt));\n    };\n    JSONPointer.prototype.getString = function (path, alt) {\n        if (alt === void 0) { alt = null; }\n        var value = this.getValue(path);\n        if (typeof value === 'string') {\n            return value;\n        }\n        else if (typeof value === 'number') {\n            return String(value);\n        }\n        return alt;\n    };\n    JSONPointer.prototype.getDate = function (path, alt) {\n        if (alt === void 0) { alt = null; }\n        var value = this.getValue(path);\n        if (typeof value === 'string' || typeof value === 'number') {\n            return new Date(value.toString());\n        }\n        return alt;\n    };\n    JSONPointer.prototype.getDurationSecs = function (path, alt) {\n        if (alt === void 0) { alt = 0; }\n        var value = this.getValue(path);\n        if (typeof value === 'object') {\n            var d = 0;\n            if (typeof value.years === 'number') {\n                d += value.years * 31557600;\n            }\n            if (typeof value.months === 'number') {\n                d += value.months * 31557600 / 12;\n            }\n            if (typeof value.weeks === 'number') {\n                d += value.weeks * 7 * 24 * 3600;\n            }\n            if (typeof value.days === 'number') {\n                d += value.days * 24 * 3600;\n            }\n            if (typeof value.hours === 'number') {\n                d += value.hours * 3600;\n            }\n            if (typeof value.minutes === 'number') {\n                d += value.minutes * 60;\n            }\n            if (typeof value.seconds === 'number') {\n                d += value.seconds;\n            }\n            return d;\n        }\n        return alt;\n    };\n    return JSONPointer;\n})();\nmodule.exports = JSONPointer;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/lib/PackageJSON.js":"'use strict';\nvar fs = require('fs');\nvar path = require('path');\nvar assertVar = require('../assertVar');\nvar fileIO = require('../fileIO');\nfunction findInfo(pmodule, dir) {\n    if (!dir) {\n        dir = path.dirname(pmodule.filename);\n    }\n    var file = path.join(dir, 'package.json');\n    if (fs.existsSync(file)) {\n        return file;\n    }\n    if (dir === '/') {\n        throw new Error('Could not find package.json up from: ' + dir);\n    }\n    else if (!dir || dir === '.') {\n        throw new Error('Cannot find package.json from unspecified directory');\n    }\n    return findInfo(pmodule, path.dirname(dir));\n}\nvar PackageJSON = (function () {\n    function PackageJSON(pkg, path) {\n        if (path === void 0) { path = null; }\n        this.path = path;\n        assertVar(pkg, 'object', 'pkg');\n        this._pkg = pkg;\n    }\n    Object.defineProperty(PackageJSON.prototype, \"raw\", {\n        get: function () {\n            return this._pkg;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PackageJSON.prototype, \"name\", {\n        get: function () {\n            return this._pkg.name || null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PackageJSON.prototype, \"description\", {\n        get: function () {\n            return this._pkg.description || '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PackageJSON.prototype, \"version\", {\n        get: function () {\n            return this._pkg.version || '0.0.0';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    PackageJSON.prototype.getNameVersion = function () {\n        return this.name + ' ' + this.version;\n    };\n    PackageJSON.prototype.getKey = function () {\n        return this.name + '-' + this.version;\n    };\n    PackageJSON.prototype.getHomepage = function (short) {\n        if (short === void 0) { short = false; }\n        var homepage = this._pkg.homepage;\n        if (homepage) {\n            if (short) {\n                return homepage.replace(/(^https?:\\/\\/)|(\\/?$)/g, '');\n            }\n            return homepage;\n        }\n        if (short) {\n            return '<no homepage>';\n        }\n        return '';\n    };\n    PackageJSON.find = function () {\n        if (!PackageJSON._localPath) {\n            PackageJSON._localPath = findInfo((module));\n        }\n        return PackageJSON._localPath;\n    };\n    PackageJSON.getLocal = function () {\n        if (!PackageJSON._local) {\n            var src = PackageJSON.find();\n            if (!src) {\n                throw (new Error('cannot find local package.json'));\n            }\n            PackageJSON._local = new PackageJSON(fileIO.readJSONSync(src), src);\n        }\n        return PackageJSON._local;\n    };\n    return PackageJSON;\n})();\nmodule.exports = PackageJSON;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/context/Config.js":"'use strict';\nvar path = require('path');\nvar Joi = require('joi');\nvar typeOf = require('../../xm/typeOf');\nvar assertVar = require('../../xm/assertVar');\nvar collection = require('../../xm/collection');\nvar JSONStabilizer = require('../../xm/lib/JSONStabilizer');\nvar Const = require('../context/Const');\nvar InstalledDef = require('../context/InstalledDef');\nvar DefVersion = require('../data/DefVersion');\nvar DefCommit = require('../data/DefCommit');\nvar Def = require('../data/Def');\nvar tsdSchema = require('../schema/config');\nvar Config = (function () {\n    function Config() {\n        this._installed = new collection.Hash();\n        this._stable = new JSONStabilizer();\n        this.reset();\n    }\n    Config.prototype.reset = function () {\n        this.path = Const.typingsDir;\n        this.version = Const.configVersion;\n        this.repo = Const.definitelyRepo;\n        this.ref = Const.mainBranch;\n        this.stats = Const.statsDefault;\n        this.otherFields = {};\n        this.bundle = Const.typingsDir + '/' + Const.bundleFile;\n        this._installed.clear();\n    };\n    Config.prototype.resolveTypingsPath = function (baseDir) {\n        var cfgFull = path.resolve(baseDir);\n        var typings = this.path.replace(/[\\\\\\/]/g, path.sep);\n        if (/^([\\\\\\/]|\\w:)/.test(this.path)) {\n            return typings;\n        }\n        return path.resolve(cfgFull, typings);\n    };\n    Object.defineProperty(Config.prototype, \"repoOwner\", {\n        get: function () {\n            return this.repo.split('/')[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Config.prototype, \"repoProject\", {\n        get: function () {\n            return this.repo.split('/')[1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Config.prototype, \"repoRef\", {\n        get: function () {\n            return this.repo + '#' + this.ref;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Config.prototype.addFile = function (file) {\n        assertVar(file, DefVersion, 'file');\n        var def;\n        if (this._installed.has(file.def.path)) {\n            def = this._installed.get(file.def.path);\n        }\n        else {\n            def = new InstalledDef(file.def.path);\n        }\n        def.update(file);\n        this._installed.set(file.def.path, def);\n    };\n    Config.prototype.hasFile = function (filePath) {\n        assertVar(filePath, 'string', 'filePath');\n        return this._installed.has(filePath);\n    };\n    Config.prototype.getFile = function (filePath) {\n        assertVar(filePath, 'string', 'filePath');\n        return this._installed.get(filePath);\n    };\n    Config.prototype.removeFile = function (filePath) {\n        assertVar(filePath, 'string', 'filePath');\n        this._installed.delete(filePath);\n    };\n    Config.prototype.getInstalled = function () {\n        return this._installed.values();\n    };\n    Config.prototype.getInstalledPaths = function () {\n        return this._installed.values().map(function (value) {\n            return value.path;\n        });\n    };\n    Config.prototype.getInstalledAsDefVersionList = function () {\n        var defs = [];\n        this.getInstalled().forEach(function (installed) {\n            defs.push(new DefVersion(new Def(installed.path), new DefCommit(installed.commitSha)));\n        });\n        return defs;\n    };\n    Config.prototype.toJSON = function () {\n        var json = this.otherFields;\n        json.version = this.version;\n        json.repo = this.repo;\n        json.ref = this.ref;\n        json.path = this.path;\n        if (this.bundle) {\n            json.bundle = this.bundle;\n        }\n        if (this.stats !== Const.statsDefault) {\n            json.stats = this.stats;\n        }\n        json.installed = {};\n        this._installed.forEach(function (file) {\n            json.installed[file.path] = {\n                commit: file.commitSha\n            };\n        });\n        this.validateJSON(json);\n        return json;\n    };\n    Config.prototype.toJSONString = function () {\n        return this._stable.toJSONString(this.toJSON(), false);\n    };\n    Config.prototype.parseJSONString = function (input, label) {\n        if (label === void 0) { label = null; }\n        assertVar(input, 'string', 'input');\n        this.parseJSON(this._stable.parseString(input), label);\n    };\n    Config.prototype.parseJSON = function (json, label) {\n        var _this = this;\n        if (label === void 0) { label = null; }\n        assertVar(json, 'object', 'json');\n        this.validateJSON(json, label);\n        this._installed.clear();\n        this.path = json.path;\n        this.version = json.version;\n        this.repo = json.repo;\n        this.ref = json.ref;\n        this.bundle = json.bundle;\n        this.stats = (typeOf.isBoolean(json.stats) ? json.stats : Const.statsDefault);\n        if (json.installed) {\n            Object.keys(json.installed).forEach(function (filePath) {\n                var data = json.installed[filePath];\n                var installed = new InstalledDef(filePath);\n                installed.commitSha = data.commit;\n                _this._installed.set(filePath, installed);\n            });\n        }\n        var reservedFields = ['path', 'version', 'repo', 'ref', 'bundle', 'stats', 'installed'];\n        var otherFieldKeys = Object.keys(json).filter(function (key) { return reservedFields.indexOf(key) === -1; });\n        this.otherFields = otherFieldKeys.reduce(function (fields, key) {\n            fields[key] = json[key];\n            return fields;\n        }, {});\n    };\n    Config.prototype.validateJSON = function (json, label) {\n        if (label === void 0) { label = null; }\n        Joi.assert(json, tsdSchema);\n        return json;\n    };\n    return Config;\n})();\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/collection.js":"'use strict';\nfunction dict() {\n    return Object.create(null);\n}\nexports.dict = dict;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar Set = (function () {\n    function Set(d) {\n        this.list = [];\n        this.list = d || [];\n    }\n    Set.prototype.has = function (value) {\n        return this.list.indexOf(value) > -1;\n    };\n    Set.prototype.add = function (value) {\n        var i = this.list.indexOf(value);\n        if (i < 0) {\n            this.list.push(value);\n        }\n    };\n    Set.prototype.delete = function (value) {\n        var i = this.list.indexOf(value);\n        if (i > -1) {\n            this.list.splice(i, 1);\n        }\n    };\n    Set.prototype.values = function () {\n        return this.list.slice(0);\n    };\n    Set.prototype.forEach = function (iterator) {\n        var arr = this.list.slice(0);\n        for (var i = 0, ii = arr.length; i < ii; i++) {\n            iterator(arr[i], i);\n        }\n    };\n    Object.defineProperty(Set.prototype, \"size\", {\n        get: function () {\n            return this.list.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Set;\n})();\nexports.Set = Set;\nvar Hash = (function () {\n    function Hash(d) {\n        var _this = this;\n        this.dict = dict();\n        if (d) {\n            Object.keys(d).forEach(function (key) {\n                _this.dict[key] = d[key];\n            });\n        }\n    }\n    Hash.prototype.has = function (key) {\n        return key in this.dict;\n    };\n    Hash.prototype.get = function (key) {\n        if (key in this.dict) {\n            return this.dict[key];\n        }\n        return null;\n    };\n    Hash.prototype.set = function (key, value) {\n        this.dict[key] = value;\n    };\n    Hash.prototype.delete = function (key) {\n        delete this.dict[key];\n    };\n    Hash.prototype.clear = function () {\n        this.dict = dict();\n    };\n    Hash.prototype.merge = function (d) {\n        for (var key in d) {\n            this.dict[key] = d[key];\n        }\n    };\n    Hash.prototype.keys = function () {\n        var keys = [];\n        for (var key in this.dict) {\n            keys.push(key);\n        }\n        return keys;\n    };\n    Hash.prototype.values = function () {\n        var values = [];\n        for (var key in this.dict) {\n            values.push(this.dict[key]);\n        }\n        return values;\n    };\n    Hash.prototype.forEach = function (iterator) {\n        var arr = this.keys();\n        for (var i = 0, ii = arr.length; i < ii; i++) {\n            var key = arr[i];\n            iterator(this.dict[key], key);\n        }\n    };\n    Object.defineProperty(Hash.prototype, \"size\", {\n        get: function () {\n            var size = 0;\n            for (var key in this.dict) {\n                size++;\n            }\n            return size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Hash;\n})();\nexports.Hash = Hash;\nfunction enumNames(enumer) {\n    return Object.keys(enumer).filter(function (value) {\n        return !/^\\d+$/.test(value);\n    });\n}\nexports.enumNames = enumNames;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/lib/JSONStabilizer.js":"'use strict';\nvar detectIndent = require('detect-indent');\nvar CodeStyle = require('../lib/CodeStyle');\nvar collection = require('../collection');\nvar assertVar = require('../assertVar');\nvar typeOf = require('../typeOf');\nvar sniffExp = /([ \\t]*).*((?:\\r?\\n)|$)/g;\nvar lastEnd = /(\\r?\\n)$/;\nvar JSONStabilizer = (function () {\n    function JSONStabilizer(depth, style) {\n        if (depth === void 0) { depth = 2; }\n        if (style === void 0) { style = null; }\n        this.keys = [];\n        this.parent = null;\n        this.children = new collection.Hash();\n        this.depth = depth;\n        this.style = style || new CodeStyle();\n    }\n    Object.defineProperty(JSONStabilizer.prototype, \"root\", {\n        get: function () {\n            if (this.parent) {\n                return this.parent.root;\n            }\n            return this;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JSONStabilizer.prototype.parseString = function (jsonString) {\n        var object = JSON.parse(jsonString.trim());\n        this.style = new CodeStyle();\n        this.sniff(jsonString);\n        this.snapshot(object);\n        return object;\n    };\n    JSONStabilizer.prototype.sniff = function (jsonString) {\n        assertVar(jsonString, 'string', 'jsonString');\n        var eolWin = 0;\n        var eolNix = 0;\n        var sampleLines = 10;\n        var match;\n        sniffExp.lastIndex = 0;\n        while (sampleLines > 0 && (match = sniffExp.exec(jsonString))) {\n            sniffExp.lastIndex = match.index + (match[0].length || 1);\n            sampleLines--;\n            if (match[2].length > 0) {\n                if (match[2] === '\\r\\n') {\n                    eolWin++;\n                }\n                else {\n                    eolNix++;\n                }\n            }\n        }\n        this.style.trailingEOL = false;\n        if (jsonString.length > 2) {\n            lastEnd.lastIndex = 0;\n            match = lastEnd.exec(jsonString);\n            if (match && match[1].length > 0) {\n                this.style.trailingEOL = true;\n                if (match[1] === '\\r\\n') {\n                    eolWin++;\n                }\n                else {\n                    eolNix++;\n                }\n            }\n        }\n        this.style.indent = detectIndent(jsonString, '  ');\n        this.style.eol = (eolWin > eolNix ? '\\r\\n' : '\\n');\n    };\n    JSONStabilizer.prototype.snapshot = function (object) {\n        var _this = this;\n        assertVar(object, 'object', 'object');\n        this.keys = Object.keys(object);\n        this.children = new collection.Hash();\n        if (this.depth > 0) {\n            this.keys.forEach(function (key) {\n                if (typeOf.isObject(object[key])) {\n                    var child = new JSONStabilizer(_this.depth - 1);\n                    child.parent = _this;\n                    _this.children[key] = child;\n                    child.snapshot(object[key]);\n                }\n            });\n        }\n    };\n    JSONStabilizer.prototype.getStablized = function (json) {\n        var _this = this;\n        assertVar(json, 'object', 'json');\n        var ret = {};\n        var have = Object.keys(json);\n        this.keys.forEach(function (key) {\n            var i = have.indexOf(key);\n            if (i > -1) {\n                have.splice(i, 1);\n                if (key in _this.children && typeOf.isObject(json[key])) {\n                    ret[key] = _this.children[key].getStablized(json[key]);\n                }\n                else {\n                    ret[key] = json[key];\n                }\n            }\n        });\n        have.forEach(function (key) {\n            _this.keys.push(key);\n            ret[key] = json[key];\n        });\n        return ret;\n    };\n    JSONStabilizer.prototype.toJSONString = function (json, assumeStable) {\n        if (assumeStable === void 0) { assumeStable = false; }\n        assertVar(json, 'object', 'json');\n        if (!assumeStable) {\n            json = this.getStablized(json);\n        }\n        var str = JSON.stringify(json, null, this.style.indent);\n        if (this.style.eol !== '\\n') {\n            str = str.replace(/\\r?\\n/g, this.style.eol);\n        }\n        if (this.style.trailingEOL) {\n            str += this.style.eol;\n        }\n        return str;\n    };\n    return JSONStabilizer;\n})();\nmodule.exports = JSONStabilizer;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/lib/CodeStyle.js":"'use strict';\nvar CodeStyle = (function () {\n    function CodeStyle() {\n        this.eol = '\\n';\n        this.indent = '  ';\n        this.trailingEOL = true;\n    }\n    CodeStyle.prototype.clone = function () {\n        var style = new CodeStyle();\n        style.eol = this.eol;\n        style.indent = this.indent;\n        style.trailingEOL = this.trailingEOL;\n        return style;\n    };\n    return CodeStyle;\n})();\nmodule.exports = CodeStyle;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/context/Const.js":"'use strict';\nvar Const = {\n    rc: '.tsdrc',\n    ident: 'tsd',\n    configFile: 'tsd.json',\n    typingsDir: 'typings',\n    cacheDir: 'tsd-cache',\n    bundleFile: 'tsd.d.ts',\n    settings: 'settings.json',\n    configVersion: 'v4',\n    definitelyRepo: 'borisyankov/DefinitelyTyped',\n    mainBranch: 'master',\n    statsDefault: true,\n    shaShorten: 6\n};\nObject.freeze(Const);\nmodule.exports = Const;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/context/InstalledDef.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar DefVersion = require('../data/DefVersion');\nvar DefCommit = require('../data/DefCommit');\nvar InstalledDef = (function () {\n    function InstalledDef(path) {\n        if (path) {\n            assertVar(path, 'string', 'path');\n            this.path = path;\n        }\n    }\n    InstalledDef.prototype.update = function (file) {\n        assertVar(file, DefVersion, 'file');\n        assertVar(file.commit, DefCommit, 'commit');\n        assertVar(file.commit.commitSha, 'sha1', 'commit.sha');\n        this.path = file.def.path;\n        this.commitSha = file.commit.commitSha;\n    };\n    InstalledDef.prototype.toString = function () {\n        return this.path;\n    };\n    return InstalledDef;\n})();\nmodule.exports = InstalledDef;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/DefVersion.js":"'use strict';\nvar VError = require('verror');\nvar assertVar = require('../../xm/assertVar');\nvar objectUtils = require('../../xm/objectUtils');\nvar defUtil = require('../util/defUtil');\nvar Def = require('./Def');\nvar DefCommit = require('./DefCommit');\nvar DefVersion = (function () {\n    function DefVersion(def, commit) {\n        this.def = null;\n        this.commit = null;\n        this._blobSha = null;\n        this.dependencies = [];\n        this.solved = false;\n        this.info = null;\n        assertVar(def, Def, 'def');\n        assertVar(commit, DefCommit, 'commit');\n        this.def = def;\n        this.commit = commit;\n        objectUtils.lockProps(this, ['def', 'commit']);\n    }\n    DefVersion.prototype.setBlob = function (sha) {\n        assertVar(sha, 'sha1', 'blob');\n        if (this._blobSha && this._blobSha !== sha) {\n            throw new VError('already got a blob but %s != %s', this._blobSha, sha);\n        }\n        this._blobSha = sha;\n    };\n    Object.defineProperty(DefVersion.prototype, \"key\", {\n        get: function () {\n            if (!this.def || !this.commit) {\n                return null;\n            }\n            return this.def.path + '-' + this.commit.commitSha;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DefVersion.prototype, \"blobSha\", {\n        get: function () {\n            return this._blobSha;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DefVersion.prototype, \"blobShaShort\", {\n        get: function () {\n            return this._blobSha ? defUtil.shaShort(this._blobSha) : '<no sha>';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DefVersion.prototype.toString = function () {\n        var str = '';\n        str += (this.def ? this.def.path : '<no def>');\n        str += ' : ' + (this.commit ? this.commit.commitShort : '<no commit>');\n        str += ' : ' + (this._blobSha ? this.blobShaShort : '<no blob>');\n        return str;\n    };\n    return DefVersion;\n})();\nmodule.exports = DefVersion;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/objectUtils.js":"'use strict';\nvar typeOf = require('./typeOf');\nfunction defineProp(object, property, settings) {\n    Object.defineProperty(object, property, settings);\n}\nexports.defineProp = defineProp;\nfunction defineProps(object, propertyNames, settings) {\n    propertyNames.forEach(function (property) {\n        defineProp(object, property, settings);\n    });\n}\nexports.defineProps = defineProps;\nfunction lockProps(object, props, ownOnly) {\n    if (ownOnly === void 0) { ownOnly = true; }\n    if (!props) {\n        Object.keys(object).forEach(function (property) {\n            Object.defineProperty(object, property, { writable: false });\n        });\n    }\n    else {\n        props.forEach(function (property) {\n            if (!ownOnly || typeOf.hasOwnProp(object, property)) {\n                Object.defineProperty(object, property, { writable: false });\n            }\n        });\n    }\n}\nexports.lockProps = lockProps;\nfunction lockPrimitives(object) {\n    Object.keys(object).forEach(function (property) {\n        if (typeOf.isPrimitive(object[property])) {\n            Object.defineProperty(object, property, { writable: false });\n        }\n    });\n}\nexports.lockPrimitives = lockPrimitives;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/util/defUtil.js":"'use strict';\nvar VError = require('verror');\nvar semver = require('semver');\nvar dateUtils = require('../../xm/dateUtils');\nvar Const = require('../context/Const');\nvar referenceTagExp = /<reference[ \\t]*path=[\"']?([\\w\\.\\/_-]*)[\"']?[ \\t]*\\/>/g;\nfunction shaShort(sha) {\n    if (!sha) {\n        return '<no sha>';\n    }\n    return sha.substr(0, Const.shaShorten);\n}\nexports.shaShort = shaShort;\nfunction getDefs(list) {\n    return list.map(function (def) {\n        return def.def;\n    });\n}\nexports.getDefs = getDefs;\nfunction getHeads(list) {\n    return list.map(function (def) {\n        return def.head;\n    });\n}\nexports.getHeads = getHeads;\nfunction getHistoryTop(list) {\n    return list.map(function (def) {\n        if (def.history.length === 1) {\n            return def.history[0];\n        }\n        else if (def.history.length > 0) {\n            return def.history.sort(fileCompare)[0];\n        }\n        return def.head;\n    });\n}\nexports.getHistoryTop = getHistoryTop;\nfunction getHistoryBottom(list) {\n    return list.map(function (def) {\n        if (def.history.length === 1) {\n            return def.history[0];\n        }\n        else if (def.history.length > 0) {\n            return def.history.sort(fileCompare)[def.history.length - 1];\n        }\n        return def.head;\n    });\n}\nexports.getHistoryBottom = getHistoryBottom;\nfunction getLatest(list) {\n    if (list.length === 1) {\n        return list[0];\n    }\n    else if (list.length > 1) {\n        return list.sort(fileCompare)[0];\n    }\n    return null;\n}\nexports.getLatest = getLatest;\nfunction getRecent(list) {\n    if (list.length === 1) {\n        return list[0];\n    }\n    else if (list.length > 1) {\n        return list.sort(fileCompare)[list.length - 1];\n    }\n    return null;\n}\nexports.getRecent = getRecent;\nfunction getPaths(list) {\n    return list.map(function (def) {\n        return def.path;\n    });\n}\nexports.getPaths = getPaths;\nfunction getPathsOf(list) {\n    return list.map(function (file) {\n        return file.def.path;\n    });\n}\nexports.getPathsOf = getPathsOf;\nfunction uniqueDefVersion(list) {\n    var ret = [];\n    outer: for (var i = 0, ii = list.length; i < ii; i++) {\n        var check = list[i];\n        for (var j = 0, jj = ret.length; j < jj; j++) {\n            if (check.def.path === ret[j].def.path) {\n                continue outer;\n            }\n        }\n        ret.push(check);\n    }\n    return ret;\n}\nexports.uniqueDefVersion = uniqueDefVersion;\nfunction uniqueDefs(list) {\n    var ret = [];\n    outer: for (var i = 0, ii = list.length; i < ii; i++) {\n        var check = list[i];\n        for (var j = 0, jj = ret.length; j < jj; j++) {\n            if (check.path === ret[j].path) {\n                continue outer;\n            }\n        }\n        ret.push(check);\n    }\n    return ret;\n}\nexports.uniqueDefs = uniqueDefs;\nfunction extractReferenceTags(source) {\n    var ret = [];\n    var match;\n    if (!referenceTagExp.global) {\n        throw new VError('referenceTagExp RegExp must have global flag');\n    }\n    referenceTagExp.lastIndex = 0;\n    while ((match = referenceTagExp.exec(source))) {\n        if (match.length > 0 && match[1].length > 0) {\n            ret.push(match[1]);\n        }\n    }\n    return ret;\n}\nexports.extractReferenceTags = extractReferenceTags;\nvar externalModules = /(?:^|\\r?\\n)declare module *(['\"])(\\w+)\\1\\s*{/g;\nfunction extractExternals(source) {\n    var ret = [];\n    var match;\n    if (!externalModules.global) {\n        throw new VError('referenceTagExp RegExp must have global flag');\n    }\n    externalModules.lastIndex = 0;\n    while ((match = externalModules.exec(source))) {\n        if (match.length >= 2 && match[2].length > 0) {\n            ret.push(match[2]);\n        }\n    }\n    return ret;\n}\nexports.extractExternals = extractExternals;\nfunction contains(list, file) {\n    var p = file.def.path;\n    for (var i = 0, ii = list.length; i < ii; i++) {\n        if (list[i].def.path === p) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.contains = contains;\nfunction containsDef(list, def) {\n    var p = def.path;\n    for (var i = 0, ii = list.length; i < ii; i++) {\n        if (list[i].path === p) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsDef = containsDef;\nfunction mergeDependencies(list, target) {\n    target = target || [];\n    for (var i = 0, ii = list.length; i < ii; i++) {\n        var file = list[i];\n        if (!contains(target, file)) {\n            target.push(file);\n            mergeDependenciesOf(file.dependencies, target);\n        }\n    }\n    return target;\n}\nexports.mergeDependencies = mergeDependencies;\nfunction mergeDependenciesOf(list, target) {\n    target = target || [];\n    for (var i = 0, ii = list.length; i < ii; i++) {\n        var file = list[i].head;\n        if (!contains(target, file)) {\n            target.push(file);\n            mergeDependenciesOf(file.dependencies, target);\n        }\n    }\n    return target;\n}\nexports.mergeDependenciesOf = mergeDependenciesOf;\nfunction matchCommit(list, commitSha) {\n    var ret = [];\n    for (var i = 0, ii = list.length; i < ii; i++) {\n        var file = list[i];\n        if (file.commit && file.commit.commitSha === commitSha) {\n            ret.push(file);\n        }\n    }\n    return ret;\n}\nexports.matchCommit = matchCommit;\nfunction fileCompare(aa, bb) {\n    if (!bb) {\n        return 1;\n    }\n    if (!aa) {\n        return -1;\n    }\n    if (aa.def.path < bb.def.path) {\n        return -1;\n    }\n    else if (aa.def.path > bb.def.path) {\n        return 1;\n    }\n    if (aa.blobSha < bb.blobSha) {\n        return -1;\n    }\n    else if (aa.blobSha > bb.blobSha) {\n        return 1;\n    }\n    return 0;\n}\nexports.fileCompare = fileCompare;\nfunction defCompare(aa, bb) {\n    if (!bb) {\n        return 1;\n    }\n    if (!aa) {\n        return -1;\n    }\n    if (aa.path < bb.path) {\n        return -1;\n    }\n    else if (aa.path > bb.path) {\n        return 1;\n    }\n    return 0;\n}\nexports.defCompare = defCompare;\nfunction defSemverCompare(aa, bb) {\n    if (!bb) {\n        return 1;\n    }\n    if (!aa) {\n        return -1;\n    }\n    if (aa.semver && !bb.semver) {\n        return -1;\n    }\n    else if (!aa.semver && bb.semver) {\n        return 1;\n    }\n    return semver.compare(aa.semver, bb.semver);\n}\nexports.defSemverCompare = defSemverCompare;\nfunction fileCommitCompare(aa, bb) {\n    var aaDate = aa.commit && aa.commit.changeDate;\n    var bbDate = bb.commit && bb.commit.changeDate;\n    if (!bbDate) {\n        return 1;\n    }\n    if (!aaDate) {\n        return -1;\n    }\n    return dateUtils.compare(aaDate, bbDate);\n}\nexports.fileCommitCompare = fileCommitCompare;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/dateUtils.js":"'use strict';\nvar stringUtils = require('./stringUtils');\nvar typeOf = require('./typeOf');\nfunction getISOString(input) {\n    var date;\n    if (typeOf.isDate(input)) {\n        date = input;\n    }\n    else if (typeOf.isString(input) || typeOf.isNumber(input)) {\n        date = new Date(input);\n    }\n    return (date ? date.toISOString() : null);\n}\nexports.getISOString = getISOString;\nfunction toNiceUTC(date) {\n    return date.getUTCFullYear()\n        + '-' + stringUtils.padLeftZero(date.getUTCMonth() + 1)\n        + '-' + stringUtils.padLeftZero(date.getUTCDate())\n        + ' ' + stringUtils.padLeftZero(date.getUTCHours())\n        + ':' + stringUtils.padLeftZero(date.getUTCMinutes());\n}\nexports.toNiceUTC = toNiceUTC;\nfunction isBeforeDate(actual, base) {\n    return actual.getUTCFullYear() < base.getUTCFullYear()\n        || actual.getUTCMonth() < base.getUTCMonth()\n        || actual.getUTCDate() < base.getUTCDate();\n}\nexports.isBeforeDate = isBeforeDate;\nfunction isAfterDate(actual, base) {\n    return actual.getUTCFullYear() > base.getUTCFullYear()\n        || actual.getUTCMonth() > base.getUTCMonth()\n        || actual.getUTCDate() > base.getUTCDate();\n}\nexports.isAfterDate = isAfterDate;\nfunction isEqualDate(actual, base) {\n    return actual.toDateString() === base.toDateString();\n}\nexports.isEqualDate = isEqualDate;\nfunction compare(date1, date2) {\n    return date1.getTime() - date2.getTime();\n}\nexports.compare = compare;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/stringUtils.js":"'use strict';\nfunction padLeftZero(input, length) {\n    if (length === void 0) { length = 2; }\n    var r = String(input);\n    while (r.length < length) {\n        r = '0' + r;\n    }\n    return r;\n}\nexports.padLeftZero = padLeftZero;\nfunction wordWrap(input, length) {\n    if (length === void 0) { length = 80; }\n    var lines = [];\n    var broken = input.split(/\\r?\\n/);\n    broken.forEach(function (line, index) {\n        var parts = line.trim().split(/[ \\t]+/g);\n        var accumulator = [];\n        var len = 0;\n        var next = parts.shift();\n        accumulator.push(next);\n        len += next.length + 1;\n        while (parts.length > 0) {\n            next = parts.shift();\n            if (len + next.length + 1 > length) {\n                lines.push(accumulator.join(' '));\n                accumulator = [];\n                len = 0;\n            }\n            accumulator.push(next);\n            len += next.length + 1;\n        }\n        if (accumulator.length > 0) {\n            lines.push(accumulator.join(' '));\n        }\n    });\n    return lines;\n}\nexports.wordWrap = wordWrap;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/Def.js":"'use strict';\nvar semver = require('semver');\nvar VError = require('verror');\nvar assertVar = require('../../xm/assertVar');\nvar objectUtils = require('../../xm/objectUtils');\nvar defExp = /^[a-z_](?:[\\._-]?[a-z0-9_])*(?:\\/[a-z_](?:[\\._-]?[a-z0-9_])*)+\\.d\\.ts$/i;\nvar versionEnd = /(?:-v?)(\\d+(?:\\.\\d+)*)(-[a-z](?:[_-]?[a-z0-9])*(?:\\.\\d+)*)?$/i;\nvar twoNums = /^\\d+\\.\\d+$/;\nvar lockProps = [\n    'path',\n    'project',\n    'name',\n    'semver',\n    'label',\n    'isLegacy',\n    'isMain',\n];\nvar legacyFolders = [\n    'legacy',\n    'releases'\n];\nvar Def = (function () {\n    function Def(path) {\n        this.path = null;\n        this.project = null;\n        this.name = null;\n        this.semver = null;\n        this.label = null;\n        this.isLegacy = false;\n        this.isMain = true;\n        this.head = null;\n        this.history = [];\n        this.releases = [];\n        assertVar(path, 'string', 'path');\n        if (!defExp.test(path)) {\n            throw new VError('cannot part path %s to Def', path);\n        }\n        this.path = path;\n        var parts = this.path.replace(/\\.d\\.ts$/, '').split(/\\//g);\n        this.project = parts[0];\n        this.name = parts.slice(1).join(':');\n        this.isMain = (parts.length === 2);\n        this.isLegacy = false;\n        if (parts.length > 2 && legacyFolders.indexOf(parts[1]) > -1) {\n            this.isLegacy = true;\n            this.name = parts.slice(2).join(':');\n            this.isMain = (parts.length === 3);\n        }\n        versionEnd.lastIndex = 0;\n        var semMatch = versionEnd.exec(this.name);\n        if (semMatch) {\n            var sem = semMatch[1];\n            if (twoNums.test(sem)) {\n                sem += '.0';\n            }\n            if (semMatch.length > 2 && typeof semMatch[2] !== 'undefined') {\n                sem += semMatch[2];\n            }\n            var valid = semver.valid(sem, true);\n            if (valid) {\n                this.semver = valid;\n                this.isLegacy = true;\n                this.name = this.name.substr(0, semMatch.index);\n            }\n            else {\n            }\n        }\n        this.label = this.project + '/' + this.name + (this.semver ? '-v' + this.semver : '');\n        objectUtils.lockProps(this, lockProps);\n    }\n    Def.prototype.toString = function () {\n        return this.path;\n    };\n    Object.defineProperty(Def.prototype, \"pathTerm\", {\n        get: function () {\n            return this.path.replace(/\\.d\\.ts$/, '');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Def.prototype, \"nameTerm\", {\n        get: function () {\n            return this.name + (this.semver ? '-v' + this.semver : '');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Def.isDefPath = function (path) {\n        return defExp.test(path);\n    };\n    Def.getFrom = function (path) {\n        if (!defExp.test(path)) {\n            return null;\n        }\n        return new Def(path);\n    };\n    return Def;\n})();\nmodule.exports = Def;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/DefCommit.js":"'use strict';\nvar assert = require('../../xm/assert');\nvar assertVar = require('../../xm/assertVar');\nvar objectUtils = require('../../xm/objectUtils');\nvar GithubUser = require('../../git/model/GithubUser');\nvar GitCommitUser = require('../../git/model/GitCommitUser');\nvar GitCommitMessage = require('../../git/model/GitCommitMessage');\nvar defUtil = require('../util/defUtil');\nvar DefCommit = (function () {\n    function DefCommit(commitSha) {\n        this.hasMeta = false;\n        this.message = new GitCommitMessage();\n        assertVar(commitSha, 'sha1', 'commitSha');\n        this.commitSha = commitSha;\n        objectUtils.lockProps(this, ['commitSha']);\n    }\n    DefCommit.prototype.parseJSON = function (commit) {\n        assertVar(commit, 'object', 'commit');\n        assert((commit.sha === this.commitSha), 'not my tree: {act}, {exp}', this.commitSha, commit.sha);\n        this.hubAuthor = GithubUser.fromJSON(commit.author);\n        this.hubCommitter = GithubUser.fromJSON(commit.committer);\n        this.gitAuthor = GitCommitUser.fromJSON(commit.commit.author);\n        this.gitCommitter = GitCommitUser.fromJSON(commit.commit.committer);\n        this.message.parse(commit.commit.message);\n        this.hasMeta = true;\n    };\n    DefCommit.prototype.hasMetaData = function () {\n        return this.hasMeta;\n    };\n    DefCommit.prototype.toString = function () {\n        return this.commitSha;\n    };\n    Object.defineProperty(DefCommit.prototype, \"changeDate\", {\n        get: function () {\n            if (this.gitAuthor) {\n                return this.gitAuthor.date;\n            }\n            if (this.gitCommitter) {\n                return this.gitCommitter.date;\n            }\n            return null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DefCommit.prototype, \"commitShort\", {\n        get: function () {\n            return this.commitSha ? defUtil.shaShort(this.commitSha) : '<no sha>';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return DefCommit;\n})();\nmodule.exports = DefCommit;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/assert.js":"'use strict';\nvar AssertionError = require('assertion-error');\nvar typeOf = require('./typeOf');\nvar inspect = require('./inspect');\nvar typeOfAssert = typeOf.getTypeOfMap();\nfunction assert(pass, message, actual, expected, showDiff, ssf) {\n    if (showDiff === void 0) { showDiff = true; }\n    if (!!pass) {\n        return;\n    }\n    if (typeOf.isString(message)) {\n        message = message.replace(/\\{([\\w]+)\\}/gi, function (match, id) {\n            switch (id) {\n                case 'a':\n                case 'act':\n                case 'actual':\n                    if (arguments.length > 2) {\n                        return inspect.toValueStrim(actual);\n                    }\n                    break;\n                case 'e':\n                case 'exp':\n                case 'expected':\n                    if (arguments.length > 3) {\n                        return inspect.toValueStrim(expected);\n                    }\n                    break;\n                default:\n                    return match;\n            }\n        });\n    }\n    else {\n        message = '';\n    }\n    throw new AssertionError(message, { actual: actual, expected: expected, showDiff: showDiff }, ssf);\n}\nmodule.exports = assert;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/model/GithubUser.js":"'use strict';\nvar GithubUser = (function () {\n    function GithubUser() {\n    }\n    GithubUser.prototype.toString = function () {\n        return (this.login ? this.login : '<no login>') + (this.id ? '[' + this.id + ']' : '<no id>');\n    };\n    GithubUser.fromJSON = function (json) {\n        if (!json) {\n            return null;\n        }\n        var ret = new GithubUser();\n        ret.id = parseInt(json.id, 10);\n        ret.login = json.login;\n        ret.avatar_url = json.avatar_url;\n        return ret;\n    };\n    return GithubUser;\n})();\nmodule.exports = GithubUser;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/model/GitCommitUser.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar GitCommitUser = (function () {\n    function GitCommitUser() {\n    }\n    GitCommitUser.prototype.toString = function () {\n        return (this.name ? this.name : '<no name>') + ' ' + (this.email ? '<' + this.email + '>' : '<no email>');\n    };\n    GitCommitUser.fromJSON = function (json) {\n        if (!json) {\n            return null;\n        }\n        assertVar(json.name, 'string', ' json.name');\n        assertVar(json.email, 'string', ' json.email');\n        var ret = new GitCommitUser();\n        ret.name = json.name;\n        ret.email = json.email;\n        ret.date = new Date(Date.parse(json.date));\n        return ret;\n    };\n    return GitCommitUser;\n})();\nmodule.exports = GitCommitUser;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/model/GitCommitMessage.js":"'use strict';\nvar subjectMessageExp = /^\\s*(\\S.*?\\S?)(?:\\s*[\\r\\n]\\s*([\\s\\S]*?))?\\s*$/;\nvar GitCommitMessage = (function () {\n    function GitCommitMessage(text) {\n        if (text === void 0) { text = null; }\n        if (text) {\n            this.parse(text);\n        }\n    }\n    GitCommitMessage.prototype.parse = function (text) {\n        this.text = String(text).trim();\n        this.subject = '';\n        this.body = '';\n        subjectMessageExp.lastIndex = 0;\n        var match = subjectMessageExp.exec(this.text);\n        if (match && match.length > 1) {\n            this.subject = String(match[1]).trim();\n            if (match.length > 2 && typeof match[2] === 'string' && match[2] !== '') {\n                this.body = match[2].replace(/\\r\\n/g, '\\n').trim();\n            }\n        }\n    };\n    GitCommitMessage.prototype.toString = function () {\n        return (typeof this.subject === 'string' ? this.subject : '<no subject>');\n    };\n    return GitCommitMessage;\n})();\nmodule.exports = GitCommitMessage;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/schema/config.js":"'use strict';\nvar Joi = require('joi');\nvar Const = require('../context/Const');\nvar schema = Joi.object({\n    version: Joi\n        .string().regex(/^v\\d+$/)\n        .default(Const.configVersion)\n        .required()\n        .description('config-format version'),\n    path: Joi\n        .string().regex(/^[\\w\\.-]+(?:\\/[\\w\\.-]+)*$/)\n        .default(Const.typingsDir)\n        .required()\n        .description('path to definition directory'),\n    repo: Joi\n        .string().regex(/^[\\w\\.-]+\\/[\\w\\.-]+$/)\n        .default(Const.definitelyRepo)\n        .required()\n        .description('github repository \"owner/name\"'),\n    ref: Joi\n        .string().regex(/^[\\w\\.-]+(?:\\/[\\w\\.-]+)*$/)\n        .default(Const.mainBranch)\n        .required()\n        .description('git ref (branch/commit'),\n    cache: Joi\n        .string()\n        .optional()\n        .description('path to (shared) tsd-cache'),\n    bundle: Joi\n        .string().regex(/\\w+\\.ts$/)\n        .default(Const.typingsDir + '/' + Const.bundleFile)\n        .optional()\n        .description('path to <reference /> bundle'),\n    stats: Joi\n        .boolean()\n        .default(Const.statsDefault)\n        .optional()\n        .description('toggle stats tracking'),\n    installed: Joi\n        .object()\n        .pattern(/^([a-z_](?:[\\._-]?[a-z0-9_]+)*)(\\/[a-z_](?:[\\._-]?[a-z0-9_]+)*)+\\.d\\.ts$/i, Joi.object({\n        commit: Joi.string()\n            .required()\n            .regex(/^[0-9a-f]{6,40}$/)\n            .description('git commit sha1 hash')\n    }))\n        .unknown(false)\n        .optional()\n        .description('installed definitions')\n}).options({\n    convert: false,\n    allowUnknown: true\n}).description('TSD config & data file');\nmodule.exports = schema;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/context/Paths.js":"'use strict';\nvar path = require('path');\nvar Const = require('./Const');\nvar Paths = (function () {\n    function Paths() {\n        this.startCwd = path.resolve(process.cwd());\n        this.configFile = path.resolve(this.startCwd, Const.configFile);\n        this.cacheDir = path.resolve(this.startCwd, Const.cacheDir);\n    }\n    Paths.getCacheDirName = function () {\n        return (process.platform === 'win32' ? Const.cacheDir : '.' + Const.cacheDir);\n    };\n    Paths.getUserHome = function () {\n        return (process.env.HOME || process.env.USERPROFILE);\n    };\n    Paths.getUserRoot = function () {\n        return (process.platform === 'win32' ? process.env.APPDATA : Paths.getUserHome());\n    };\n    Paths.getUserCacheDir = function () {\n        return path.resolve(Paths.getUserRoot(), Paths.getCacheDirName());\n    };\n    return Paths;\n})();\nmodule.exports = Paths;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/Query.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar NameMatcher = require('./NameMatcher');\nvar VersionMatcher = require('./VersionMatcher');\nvar Query = (function () {\n    function Query(pattern) {\n        this.patterns = [];\n        this.parseInfo = false;\n        this.loadHistory = false;\n        assertVar(pattern, 'string', 'pattern', true);\n        if (pattern) {\n            this.patterns.push(new NameMatcher(pattern));\n        }\n    }\n    Query.prototype.addNamePattern = function (pattern) {\n        assertVar(pattern, 'string', 'pattern');\n        this.patterns.push(new NameMatcher(pattern));\n    };\n    Query.prototype.setVersionRange = function (range) {\n        assertVar(range, 'string', 'range');\n        this.versionMatcher = new VersionMatcher(range);\n    };\n    Object.defineProperty(Query.prototype, \"requiresHistory\", {\n        get: function () {\n            return !!(this.dateMatcher || this.commitMatcher || this.loadHistory);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.toString = function () {\n        return this.patterns.map(function (matcher) {\n            return matcher.pattern;\n        }).join(', ');\n    };\n    return Query;\n})();\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/NameMatcher.js":"'use strict';\nvar VError = require('verror');\nvar minimatch = require('minimatch');\nvar assertVar = require('../../xm/assertVar');\nvar NameMatcher = (function () {\n    function NameMatcher(pattern) {\n        assertVar(pattern, 'string', 'pattern');\n        this.pattern = pattern;\n    }\n    NameMatcher.prototype.filter = function (list) {\n        return list.filter(this.getFilterFunc());\n    };\n    NameMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    NameMatcher.prototype.getFilterFunc = function () {\n        if (!this.pattern) {\n            throw (new VError('NameMatcher undefined pattern'));\n        }\n        var parts = this.pattern.split(/\\//g);\n        var projectPattern;\n        var namePattern;\n        var miniopts = {\n            nocase: true\n        };\n        if (parts.length === 1) {\n            if (parts[0].length > 0 && parts[0] !== '*') {\n                namePattern = minimatch.filter(parts[0], miniopts);\n            }\n        }\n        else {\n            if (parts[0].length > 0 && parts[0] !== '*') {\n                projectPattern = minimatch.filter(parts[0], miniopts);\n            }\n            if (parts[1].length > 0 && parts[1] !== '*') {\n                namePattern = minimatch.filter(parts.slice(1).join(':'), miniopts);\n            }\n        }\n        if (namePattern) {\n            if (projectPattern) {\n                return function (file) {\n                    return projectPattern(file.project) && namePattern(file.name);\n                };\n            }\n            else {\n                return function (file) {\n                    return namePattern(file.name);\n                };\n            }\n        }\n        else if (projectPattern) {\n            return function (file) {\n                return projectPattern(file.project);\n            };\n        }\n        else {\n            return function (file) {\n                return true;\n            };\n        }\n    };\n    return NameMatcher;\n})();\nmodule.exports = NameMatcher;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/VersionMatcher.js":"'use strict';\nvar semver = require('semver');\nvar assert = require('../../xm/assert');\nvar intMax = 900719925474;\nvar semverMax = 'v' + intMax + '.' + intMax + '.' + intMax;\nvar semverMin = 'v' + 0 + '.' + 0 + '.' + 0;\nvar VersionMatcher = (function () {\n    function VersionMatcher(range) {\n        if (range === VersionMatcher.latest || range === VersionMatcher.all) {\n            this.range = range;\n        }\n        else if (range) {\n            this.range = semver.validRange(range, true);\n            assert(!!this.range, 'expected {a} to be a valid semver-range', range);\n        }\n        else {\n            this.range = VersionMatcher.latest;\n        }\n    }\n    VersionMatcher.prototype.filter = function (list) {\n        var _this = this;\n        if (!this.range || this.range === VersionMatcher.all) {\n            return list.slice(0);\n        }\n        var map = list.reduce(function (map, def) {\n            var id = def.project + '/' + def.name;\n            if (id in map) {\n                map[id].push(def);\n            }\n            else {\n                map[id] = [def];\n            }\n            return map;\n        }, Object.create(null));\n        if (this.range === VersionMatcher.latest) {\n            return Object.keys(map).map(function (key) {\n                return _this.getLatest(map[key]);\n            });\n        }\n        return Object.keys(map).reduce(function (memo, key) {\n            map[key].forEach(function (def) {\n                if (!def.semver) {\n                    if (semver.satisfies(semverMax, _this.range)) {\n                        memo.push(def);\n                    }\n                }\n                else if (semver.satisfies(def.semver, _this.range)) {\n                    memo.push(def);\n                }\n            });\n            return memo;\n        }, []);\n    };\n    VersionMatcher.prototype.getLatest = function (list) {\n        var latest;\n        for (var i = 0, ii = list.length; i < ii; i++) {\n            var def = list[i];\n            if (!def.semver) {\n                return def;\n            }\n            else if (!latest) {\n                latest = def;\n            }\n            else if (semver.gt(def.semver, latest.semver)) {\n                latest = def;\n            }\n        }\n        return latest;\n    };\n    VersionMatcher.latest = 'latest';\n    VersionMatcher.all = 'all';\n    return VersionMatcher;\n})();\nmodule.exports = VersionMatcher;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/Selection.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar Query = require('./Query');\nvar Selection = (function () {\n    function Selection(query) {\n        if (query === void 0) { query = null; }\n        assertVar(query, Query, 'query', true);\n        this.query = query;\n    }\n    return Selection;\n})();\nmodule.exports = Selection;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/InstallResult.js":"'use strict';\nvar collection = require('../../xm/collection');\nvar assertVar = require('../../xm/assertVar');\nvar Options = require('../Options');\nvar InstallResult = (function () {\n    function InstallResult(options) {\n        this.written = new collection.Hash();\n        this.removed = new collection.Hash();\n        this.skipped = new collection.Hash();\n        assertVar(options, Options, 'options');\n        this.options = options;\n    }\n    return InstallResult;\n})();\nmodule.exports = InstallResult;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/Options.js":"'use strict';\nvar typeOf = require('../xm/typeOf');\nvar assertVar = require('../xm/assertVar');\nvar Options = (function () {\n    function Options() {\n        this.minMatches = 0;\n        this.maxMatches = 0;\n        this.limitApi = 5;\n        this.resolveDependencies = false;\n        this.overwriteFiles = false;\n        this.saveToConfig = false;\n        this.saveBundle = false;\n        this.reinstallClean = false;\n        this.addToBundles = [];\n    }\n    Options.fromJSON = function (json) {\n        var opts = new Options();\n        if (json) {\n            Object.keys(opts).forEach(function (key) {\n                if (key in json) {\n                    assertVar(json[key], typeOf.get(opts[key]), 'json[' + key + ']');\n                    opts[key] = json[key];\n                }\n            });\n        }\n        return opts;\n    };\n    Options.main = Object.freeze(new Options());\n    return Options;\n})();\nmodule.exports = Options;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/Core.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar typeOf = require('../../xm/typeOf');\nvar CacheMode = require('../../http/CacheMode');\nvar GithubRepo = require('../../git/GithubRepo');\nvar Context = require('../context/Context');\nvar IndexManager = require('./IndexManager');\nvar SelectorQuery = require('./SelectorQuery');\nvar ConfigIO = require('./ConfigIO');\nvar ContentLoader = require('./ContentLoader');\nvar InfoParser = require('./InfoParser');\nvar Installer = require('./Installer');\nvar Resolver = require('./Resolver');\nvar Core = (function () {\n    function Core(context) {\n        this._apiCacheMode = CacheMode[CacheMode.allowUpdate];\n        this._rawCacheMode = CacheMode[CacheMode.allowUpdate];\n        assertVar(context, Context, 'context');\n        this.context = context;\n        this.index = new IndexManager(this);\n        this.config = new ConfigIO(this);\n        this.selector = new SelectorQuery(this);\n        this.content = new ContentLoader(this);\n        this.parser = new InfoParser(this);\n        this.installer = new Installer(this);\n        this.resolver = new Resolver(this);\n        this.updateConfig();\n    }\n    Core.prototype.updateConfig = function () {\n        this.repo = new GithubRepo(this.context.config, this.context.paths.cacheDir, this.context.settings);\n        this.repo.api.headers['user-agent'] = this.context.packageInfo.getNameVersion();\n        this.repo.raw.headers['user-agent'] = this.context.packageInfo.getNameVersion();\n        var token = process.env.TSD_GITHUB_TOKEN || this.context.settings.getValue('/token');\n        if (typeOf.isString(token)) {\n            this.repo.api.headers['authorization'] = 'token ' + token;\n        }\n        else {\n            delete this.repo.api.headers['authorization'];\n        }\n        this.useCacheMode(this._apiCacheMode, this._rawCacheMode);\n    };\n    Core.prototype.useCacheMode = function (modeName, rawMode) {\n        if (!(modeName in CacheMode)) {\n            throw new Error('invalid CacheMode' + modeName);\n        }\n        if (rawMode && !(rawMode in CacheMode)) {\n            throw new Error('invalid CacheMode ' + rawMode);\n        }\n        this._apiCacheMode = modeName;\n        this._rawCacheMode = (rawMode || modeName);\n        this.repo.api.cache.opts.cache.applyCacheMode(CacheMode[this._apiCacheMode]);\n        this.repo.raw.cache.opts.cache.applyCacheMode(CacheMode[this._rawCacheMode]);\n    };\n    return Core;\n})();\nmodule.exports = Core;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/CacheMode.js":"'use strict';\nvar CacheMode;\n(function (CacheMode) {\n    CacheMode[CacheMode[\"forceLocal\"] = 1] = \"forceLocal\";\n    CacheMode[CacheMode[\"forceRemote\"] = 2] = \"forceRemote\";\n    CacheMode[CacheMode[\"forceUpdate\"] = 3] = \"forceUpdate\";\n    CacheMode[CacheMode[\"allowRemote\"] = 4] = \"allowRemote\";\n    CacheMode[CacheMode[\"allowUpdate\"] = 5] = \"allowUpdate\";\n})(CacheMode || (CacheMode = {}));\nmodule.exports = CacheMode;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/GithubRepo.js":"'use strict';\nvar path = require('path');\nvar assertVar = require('../xm/assertVar');\nvar JSONPointer = require('../xm/lib/JSONPointer');\nvar GithubURLs = require('./GithubURLs');\nvar GithubAPI = require('./loader/GithubAPI');\nvar GithubRaw = require('./loader/GithubRaw');\nvar GithubRepo = (function () {\n    function GithubRepo(config, storeDir, opts) {\n        assertVar(config, 'object', 'config');\n        assertVar(storeDir, 'string', 'storeDir');\n        assertVar(opts, JSONPointer, 'opts');\n        this.config = config;\n        this.urls = new GithubURLs(this);\n        this.storeDir = path.join(storeDir.replace(/[\\\\\\/]+$/, ''), this.getCacheKey());\n        this.api = new GithubAPI(this.urls, opts.getChild('git/api'), opts, this.storeDir);\n        this.raw = new GithubRaw(this.urls, opts.getChild('git/raw'), opts, this.storeDir);\n    }\n    GithubRepo.prototype.getCacheKey = function () {\n        return this.config.repoOwner + '-' + this.config.repoProject;\n    };\n    GithubRepo.prototype.toString = function () {\n        return this.config.repoOwner + '/' + this.config.repoProject;\n    };\n    Object.defineProperty(GithubRepo.prototype, \"verbose\", {\n        set: function (verbose) {\n            this.api.verbose = verbose;\n            this.raw.verbose = verbose;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return GithubRepo;\n})();\nmodule.exports = GithubRepo;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/GithubURLs.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar assertVar = require('../xm/assertVar');\nvar URLManager = require('../xm/lib/URLManager');\nvar GithubURLs = (function (_super) {\n    __extends(GithubURLs, _super);\n    function GithubURLs(repo) {\n        _super.call(this);\n        this._base = 'https://github.com/{owner}/{project}';\n        this._apiBase = 'https://api.github.com';\n        this._api = 'https://api.github.com/repos/{owner}/{project}';\n        this._raw = 'https://raw.githubusercontent.com/{owner}/{project}';\n        assertVar(repo, 'object', 'repo');\n        this._repo = repo;\n        this.addTemplate('base', this._base);\n        this.addTemplate('raw', this._raw);\n        this.addTemplate('rawFile', this._raw + '/{+ref}/{+path}');\n        this.addTemplate('htmlFile', this._base + '/blob/{ref}/{+path}');\n        this.addTemplate('api', this._api);\n        this.addTemplate('apiTree', this._api + '/git/trees/{tree}?recursive={recursive}');\n        this.addTemplate('apiBranch', this._api + '/branches/{branch}');\n        this.addTemplate('apiBranches', this._api + '/branches');\n        this.addTemplate('apiCommit', this._api + '/commits/{commit}');\n        this.addTemplate('apiPathCommits', this._api + '/commits?path={path}');\n        this.addTemplate('apiBlob', this._api + '/git/blobs/{blob}');\n        this.addTemplate('rateLimit', this._apiBase + '/rate_limit');\n    }\n    GithubURLs.prototype.getURL = function (id, vars) {\n        this.setVars({\n            owner: this._repo.config.repoOwner,\n            project: this._repo.config.repoProject\n        });\n        return _super.prototype.getURL.call(this, id, vars);\n    };\n    GithubURLs.prototype.api = function () {\n        return this.getURL('api');\n    };\n    GithubURLs.prototype.base = function () {\n        return this.getURL('base');\n    };\n    GithubURLs.prototype.raw = function () {\n        return this.getURL('raw');\n    };\n    GithubURLs.prototype.rawFile = function (ref, path) {\n        assertVar(ref, 'string', 'ref');\n        assertVar(path, 'string', 'path');\n        return this.getURL('rawFile', {\n            ref: ref,\n            path: path\n        });\n    };\n    GithubURLs.prototype.htmlFile = function (ref, path) {\n        assertVar(ref, 'string', 'ref');\n        assertVar(path, 'string', 'path');\n        return this.getURL('htmlFile', {\n            ref: ref,\n            path: path\n        });\n    };\n    GithubURLs.prototype.apiBranches = function () {\n        return this.getURL('apiBranches');\n    };\n    GithubURLs.prototype.apiBranch = function (name) {\n        assertVar(name, 'string', 'name');\n        return this.getURL('apiBranch', {\n            branch: name\n        });\n    };\n    GithubURLs.prototype.apiTree = function (tree, recursive) {\n        assertVar(tree, 'sha1', 'tree');\n        return this.getURL('apiTree', {\n            tree: tree,\n            recursive: (recursive ? 1 : 0)\n        });\n    };\n    GithubURLs.prototype.apiPathCommits = function (path) {\n        assertVar(path, 'string', 'path');\n        return this.getURL('apiPathCommits', {\n            path: path\n        });\n    };\n    GithubURLs.prototype.apiCommit = function (commit, recursive) {\n        assertVar(commit, 'sha1', 'commit');\n        return this.getURL('apiCommit', {\n            commit: commit,\n            recursive: recursive\n        });\n    };\n    GithubURLs.prototype.apiBlob = function (sha) {\n        assertVar(sha, 'sha1', 'sha');\n        return this.getURL('apiBlob', {\n            blob: sha\n        });\n    };\n    GithubURLs.prototype.rateLimit = function () {\n        return this.getURL('rateLimit');\n    };\n    return GithubURLs;\n})(URLManager);\nmodule.exports = GithubURLs;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/lib/URLManager.js":"'use strict';\nvar uriTemplates = require('uri-templates');\nvar typeOf = require('../typeOf');\nvar URLManager = (function () {\n    function URLManager(common) {\n        this._templates = Object.create(null);\n        this._vars = Object.create(null);\n        if (common) {\n            this.setVars(common);\n        }\n    }\n    URLManager.prototype.addTemplate = function (id, url) {\n        if (id in this._templates) {\n            throw (new Error('cannot redefine template: ' + id));\n        }\n        this._templates[id] = uriTemplates(url);\n    };\n    URLManager.prototype.setVar = function (id, value) {\n        this._vars[id] = value;\n    };\n    URLManager.prototype.getVar = function (id) {\n        return (id in this._vars ? this._vars[id] : null);\n    };\n    URLManager.prototype.setVars = function (map) {\n        var _this = this;\n        Object.keys(map).forEach(function (id) {\n            if (typeOf.isValid(map[id])) {\n                _this._vars[id] = map[id];\n            }\n            else {\n                delete _this._vars[id];\n            }\n        });\n    };\n    URLManager.prototype.getTemplate = function (id) {\n        if (id in this._templates) {\n            return this._templates[id];\n        }\n        throw (new Error('undefined url template: ' + id));\n    };\n    URLManager.prototype.getURL = function (id, vars) {\n        if (vars) {\n            var obj = Object.create(this._vars);\n            Object.keys(vars).forEach(function (id) {\n                if (typeOf.isValid(vars[id])) {\n                    obj[id] = vars[id];\n                }\n            });\n            return this.getTemplate(id).fillFromObject(obj);\n        }\n        return this.getTemplate(id).fillFromObject(this._vars);\n    };\n    return URLManager;\n})();\nmodule.exports = URLManager;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/loader/GithubAPI.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar request = require('request');\nvar Promise = require('bluebird');\nvar typeOf = require('../../xm/typeOf');\nvar CacheRequest = require('../../http/CacheRequest');\nvar GithubLoader = require('./GithubLoader');\nvar GithubRateInfo = require('../model/GithubRateInfo');\nvar GithubAPI = (function (_super) {\n    __extends(GithubAPI, _super);\n    function GithubAPI(urls, options, shared, storeDir) {\n        _super.call(this, urls, options, shared, storeDir, 'GithubAPI');\n        this.apiVersion = '3.0.0';\n        this.formatVersion = '1.0';\n        this._initGithubLoader();\n    }\n    GithubAPI.prototype.getBranches = function () {\n        return this.getCachableURL(this.urls.apiBranches());\n    };\n    GithubAPI.prototype.getBranch = function (branch) {\n        return this.getCachableURL(this.urls.apiBranch(branch));\n    };\n    GithubAPI.prototype.getTree = function (sha, recursive) {\n        return this.getCachableURL(this.urls.apiTree(sha, (recursive ? 1 : undefined)));\n    };\n    GithubAPI.prototype.getCommit = function (sha) {\n        return this.getCachableURL(this.urls.apiCommit(sha));\n    };\n    GithubAPI.prototype.getBlob = function (sha) {\n        return this.getCachableURL(this.urls.apiBlob(sha));\n    };\n    GithubAPI.prototype.getPathCommits = function (path) {\n        return this.getCachableURL(this.urls.apiPathCommits(path));\n    };\n    GithubAPI.prototype.getCachableURL = function (url) {\n        var request = new CacheRequest(url);\n        return this.getCachable(request);\n    };\n    GithubAPI.prototype.getCachable = function (request) {\n        if (!typeOf.isNumber(request.localMaxAge)) {\n            request.localMaxAge = this.options.getDurationSecs('localMaxAge') * 1000;\n        }\n        if (!typeOf.isNumber(request.httpInterval)) {\n            request.httpInterval = this.options.getDurationSecs('httpInterval') * 1000;\n        }\n        this.copyHeadersTo(request.headers);\n        request.headers['accept'] = 'application/vnd.github.beta+json';\n        request.lock();\n        return this.cache.getObject(request).then(function (object) {\n            var res = JSON.parse(object.body.toString('utf8'));\n            if (object.response) {\n                var rate = new GithubRateInfo(object.response.headers);\n                if (typeOf.isObject(res)) {\n                    res.meta = { rate: rate };\n                }\n            }\n            return res;\n        });\n    };\n    GithubAPI.prototype.getRateInfo = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var url = _this.urls.rateLimit();\n            var req = {\n                url: url,\n                headers: {}\n            };\n            _this.copyHeadersTo(req.headers);\n            if (_this.cache.opts.proxy) {\n                req.proxy = _this.cache.opts.proxy;\n            }\n            request.get(req, function (err, res, body) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    var rate = new GithubRateInfo(res.headers);\n                    resolve(rate);\n                }\n            });\n        });\n    };\n    GithubAPI.prototype.getCacheKey = function () {\n        return 'git-api-v' + this.apiVersion + '-fmt' + this.formatVersion;\n    };\n    return GithubAPI;\n})(GithubLoader);\nmodule.exports = GithubAPI;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/CacheRequest.js":"'use strict';\nvar deepFreeze = require('deep-freeze');\nvar hash = require('../xm/hash');\nvar Request = (function () {\n    function Request(url, headers) {\n        var _this = this;\n        this.url = url;\n        this.headers = {};\n        if (headers) {\n            Object.keys(headers).forEach(function (key) {\n                _this.headers[key] = headers[key];\n            });\n        }\n    }\n    Request.prototype.lock = function () {\n        var _this = this;\n        this.locked = true;\n        var keyHash = {\n            url: this.url,\n            headers: Object.keys(this.headers).reduce(function (memo, key) {\n                if (Request.keyHeaders.indexOf(key) > -1) {\n                    memo[key] = _this.headers[key];\n                }\n                return memo;\n            }, Object.create(null))\n        };\n        this.key = hash.jsonToIdentHash(keyHash);\n        deepFreeze(this.headers);\n        Object.freeze(this);\n        return this;\n    };\n    Request.lockProps = [\n        'key',\n        'url',\n        'headers',\n        'localMaxAge',\n        'httpInterval',\n        'forceRefresh',\n        'locked'\n    ];\n    Request.keyHeaders = [\n        'accept',\n        'accept-charset',\n        'accept-language',\n        'content-md5',\n        'content-type',\n        'cookie',\n        'host'\n    ];\n    return Request;\n})();\nmodule.exports = Request;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/xm/hash.js":"'use strict';\nvar crypto = require('crypto');\nvar typeDetect = require('type-detect');\nfunction md5(data) {\n    return crypto.createHash('md5').update(data).digest('hex');\n}\nexports.md5 = md5;\nfunction sha1(data) {\n    return crypto.createHash('sha1').update(data).digest('hex');\n}\nexports.sha1 = sha1;\nvar hashNormExp = /[\\r\\n]+/g;\nvar hashNew = '\\n';\nfunction hashNormalines(input) {\n    return sha1(input.replace(hashNormExp, hashNew));\n}\nexports.hashNormalines = hashNormalines;\nfunction hashStep(hasher, obj) {\n    var sep = ';';\n    var type = typeDetect(obj);\n    switch (type) {\n        case 'number':\n        case 'boolean':\n        case 'null':\n            hasher.update(String(obj) + sep);\n            break;\n        case 'string':\n            hasher.update(JSON.stringify(obj) + sep);\n            break;\n        case 'array':\n            hasher.update('[');\n            obj.forEach(function (value) {\n                hashStep(hasher, value);\n            });\n            hasher.update(']' + sep);\n            break;\n        case 'object':\n            var keys = Object.keys(obj);\n            keys.sort();\n            hasher.update('{');\n            keys.forEach(function (key) {\n                hasher.update(JSON.stringify(key) + ':');\n                hashStep(hasher, obj[key]);\n            });\n            hasher.update('}' + sep);\n            break;\n        case 'date':\n            hasher.update('<Date>' + obj.getTime() + sep);\n            break;\n        case 'buffer':\n            hasher.update('<Buffer>');\n            hasher.update(obj);\n            hasher.update(sep);\n            break;\n        case 'regexp':\n            throw (new Error('jsonToIdent: cannot serialise regexp'));\n        case 'function':\n            throw (new Error('jsonToIdent: cannot serialise function'));\n        default:\n            throw (new Error('jsonToIdent: cannot serialise value: ' + String(obj)));\n    }\n}\nfunction jsonToIdentHash(obj, length) {\n    if (length === void 0) { length = 0; }\n    var hash = crypto.createHash('sha1');\n    hashStep(hash, obj);\n    if (length > 0) {\n        return hash.digest('hex').substr(0, Math.min(length, 40));\n    }\n    return hash.digest('hex');\n}\nexports.jsonToIdentHash = jsonToIdentHash;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/loader/GithubLoader.js":"'use strict';\nvar path = require('path');\nvar assertVar = require('../../xm/assertVar');\nvar HTTPCache = require('../../http/HTTPCache');\nvar CacheOpts = require('../../http/CacheOpts');\nvar JSONPointer = require('../../xm/lib/JSONPointer');\nvar GithubURLs = require('../GithubURLs');\nvar GithubLoader = (function () {\n    function GithubLoader(urls, options, shared, storeDir, label) {\n        this.label = 'github-loader';\n        this.formatVersion = '0.0.0';\n        this.headers = {};\n        assertVar(urls, GithubURLs, 'urls');\n        assertVar(options, JSONPointer, 'options');\n        assertVar(shared, JSONPointer, 'shared');\n        assertVar(storeDir, 'string', 'storeDir');\n        this.urls = urls;\n        this.options = options;\n        this.shared = shared;\n        this.storeDir = storeDir;\n        this.label = label;\n    }\n    GithubLoader.prototype._initGithubLoader = function () {\n        var cache = new CacheOpts();\n        cache.allowClean = this.options.getBoolean('allowClean', cache.allowClean);\n        cache.cleanInterval = this.options.getDurationSecs('cacheCleanInterval', cache.cleanInterval / 1000) * 1000;\n        cache.splitDirLevel = this.options.getNumber('splitDirLevel', cache.splitDirLevel);\n        cache.splitDirChunk = this.options.getNumber('splitDirChunk', cache.splitDirChunk);\n        cache.jobTimeout = this.options.getDurationSecs('jobTimeout', cache.jobTimeout / 1000) * 1000;\n        cache.storeDir = path.join(this.storeDir, this.getCacheKey());\n        var opts = {\n            cache: cache,\n            concurrent: this.shared.getNumber('concurrent', 20),\n            oath: this.shared.getString('oath', null),\n            strictSSL: this.shared.getBoolean('strictSSL', true)\n        };\n        opts.proxy = (this.shared.getString('proxy')\n            || process.env.HTTPS_PROXY\n            || process.env.https_proxy\n            || process.env.HTTP_PROXY\n            || process.env.http_proxy);\n        this.cache = new HTTPCache(opts);\n        this.headers['user-agent'] = this.label + '-v' + this.formatVersion;\n    };\n    GithubLoader.prototype.getCacheKey = function () {\n        return 'loader';\n    };\n    GithubLoader.prototype.copyHeadersTo = function (target, source) {\n        source = (source || this.headers);\n        Object.keys(source).forEach(function (name) {\n            target[name] = source[name];\n        });\n    };\n    Object.defineProperty(GithubLoader.prototype, \"verbose\", {\n        set: function (verbose) {\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return GithubLoader;\n})();\nmodule.exports = GithubLoader;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/HTTPCache.js":"'use strict';\nvar path = require('path');\nvar Promise = require('bluebird');\nvar joiAssert = require('joi-assert');\nvar fileIO = require('../xm/fileIO');\nvar assert = require('../xm/assert');\nvar assertVar = require('../xm/assertVar');\nvar typeOf = require('../xm/typeOf');\nvar collection = require('../xm/collection');\nvar CacheRequest = require('./CacheRequest');\nvar CacheStreamLoader = require('./CacheStreamLoader');\nvar types = require('./types');\nvar QueueItem = (function () {\n    function QueueItem(job) {\n        this.job = job;\n        this.defer = Promise.defer();\n    }\n    QueueItem.prototype.run = function () {\n        var _this = this;\n        this.job.getObject().then(function (object) {\n            _this.defer.resolve(object);\n        }, function (err) {\n            _this.defer.reject(err);\n        });\n        return this.defer.promise;\n    };\n    Object.defineProperty(QueueItem.prototype, \"promise\", {\n        get: function () {\n            return this.defer.promise;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return QueueItem;\n})();\nvar HTTPCache = (function () {\n    function HTTPCache(opts) {\n        this.jobs = new collection.Hash();\n        this.jobTimers = new collection.Hash();\n        this.queue = [];\n        this.active = [];\n        assertVar(opts, 'object', 'opts');\n        this.opts = opts;\n        this.setStoreDir(this.opts.cache.storeDir);\n    }\n    HTTPCache.prototype.setStoreDir = function (dir) {\n        assertVar(dir, 'string', 'dir');\n        this.manageFile = path.join(dir, '_info.json');\n    };\n    HTTPCache.prototype.getObject = function (request) {\n        var _this = this;\n        assertVar(request, CacheRequest, 'request');\n        assert(request.locked, 'request must be lock()-ed {a}', request.url);\n        return this.init().then(function () {\n            if (_this.jobs.has(request.key)) {\n                return _this.jobs.get(request.key);\n            }\n            else {\n                var job = new CacheStreamLoader(_this.opts, request);\n                var item = new QueueItem(job);\n                _this.jobs.set(request.key, item.promise);\n                _this.queue.push(item);\n                _this.checkQueue();\n                return item.promise;\n            }\n        }).then(function (res) {\n            _this.scheduleRelease(request.key);\n            _this.checkCleanCache();\n            return res;\n        });\n    };\n    HTTPCache.prototype.checkQueue = function () {\n        var max = (this.opts.concurrent || 20);\n        while (this.active.length < max && this.queue.length > 0) {\n            this.step(this.queue.shift());\n        }\n    };\n    HTTPCache.prototype.step = function (item) {\n        var _this = this;\n        this.active.push(item);\n        item.run().then(function () {\n            var i = _this.active.indexOf(item);\n            if (i > -1) {\n                _this.active.splice(i);\n            }\n            _this.checkQueue();\n        });\n    };\n    HTTPCache.prototype.scheduleRelease = function (key) {\n        var _this = this;\n        if (!this.jobs.has(key)) {\n            return;\n        }\n        if (this.jobTimers.has(key)) {\n            clearTimeout(this.jobTimers.get(key));\n        }\n        if (this.opts.cache.jobTimeout <= 0) {\n            this.jobs.delete(key);\n        }\n        else {\n            var timer = setTimeout(function () {\n                _this.jobs.delete(key);\n            }, this.opts.cache.jobTimeout);\n            timer.unref();\n            this.jobTimers.set(key, timer);\n        }\n    };\n    HTTPCache.prototype.init = function () {\n        if (this._init) {\n            return this._init;\n        }\n        return this._init = fileIO.mkdirCheck(this.opts.cache.storeDir, true).return();\n    };\n    HTTPCache.prototype.checkCleanCache = function () {\n        var _this = this;\n        if (this._cleaning) {\n            return this._cleaning;\n        }\n        if (!this._init || !this.opts.cache.allowClean || !typeOf.isNumber(this.opts.cache.cleanInterval)) {\n            return Promise.resolve();\n        }\n        if (this.cacheSweepLast && this.cacheSweepLast.getTime() > Date.now() - this.opts.cache.cleanInterval) {\n            return Promise.resolve();\n        }\n        var now = new Date();\n        return this._cleaning = fileIO.exists(this.manageFile).then(function (exists) {\n            if (!exists) {\n                return null;\n            }\n            return fileIO.read(_this.manageFile).then(function (buffer) {\n                return joiAssert(JSON.parse(buffer.toString('utf8')), types.manageSchema);\n            }, function (err) {\n                return fileIO.removeFile(_this.manageFile).catch(function (err) {\n                    return null;\n                });\n            });\n        }).then(function (manageInfo) {\n            if (manageInfo) {\n                var date = new Date(manageInfo.lastSweep);\n                if (date.getTime() > now.getTime() - _this.opts.cache.cleanInterval) {\n                    return;\n                }\n            }\n            return _this.cleanupCacheAge(_this.opts.cache.cleanInterval).then(function () {\n                if (!manageInfo) {\n                    manageInfo = {\n                        lastSweep: now.toISOString()\n                    };\n                }\n                else {\n                    manageInfo.lastSweep = now.toISOString();\n                }\n                return fileIO.write(_this.manageFile, new Buffer(JSON.stringify(manageInfo, null, 2), 'utf8'));\n            });\n        }).finally(function () {\n            _this.cacheSweepLast = new Date();\n            _this._cleaning = null;\n        });\n    };\n    HTTPCache.prototype.cleanupCacheAge = function (maxAge) {\n        var _this = this;\n        assertVar(maxAge, 'number', 'maxAge');\n        return this.init().then(function () {\n            var ageLimit = Date.now() - maxAge;\n            var dirs = Object.create(null);\n            var files = [];\n            var baseDir = path.resolve(_this.opts.cache.storeDir);\n            var hexStartExp = /^[0-9a-f]+/;\n            return fileIO.listTree(baseDir).map(function (target) {\n                var first = path.relative(baseDir, target).match(hexStartExp);\n                if (first && first.length > 0) {\n                    if (!(first[0] in dirs)) {\n                        dirs[first[0]] = path.join(baseDir, first[0]);\n                    }\n                }\n                return fileIO.stat(target).then(function (stat) {\n                    if (stat.isFile()) {\n                        files.push({\n                            atime: stat.atime.getTime(),\n                            path: target\n                        });\n                    }\n                    return target;\n                });\n            }).then(function () {\n                var removeFiles = files.filter(function (obj) {\n                    var ext = path.extname(obj.path);\n                    var first = path.relative(baseDir, obj.path).match(hexStartExp);\n                    if (!first || first.length === 0) {\n                        return false;\n                    }\n                    var name = path.basename(obj.path, ext);\n                    if (!typeOf.isSha(name)) {\n                        delete dirs[first[0]];\n                        return false;\n                    }\n                    if (ext !== '.json' && ext !== '.raw') {\n                        delete dirs[first[0]];\n                        return false;\n                    }\n                    if (maxAge > 0 && obj.atime > ageLimit) {\n                        delete dirs[first[0]];\n                        return false;\n                    }\n                    return true;\n                }).map(function (obj) { return obj.path; });\n                var removeDirs = Object.keys(dirs).map(function (key) { return dirs[key]; });\n                removeFiles = removeFiles.filter(function (file) {\n                    return removeDirs.every(function (dir) {\n                        return file.indexOf(dir) !== 0;\n                    });\n                });\n                return Promise.map(removeFiles, function (target) {\n                    return fileIO.removeFile(target);\n                }).then(function () {\n                    return Promise.map(removeDirs, function (dir) {\n                        return fileIO.rimraf(dir);\n                    });\n                }).catch(function (e) {\n                    console.log('\\n-removeFile error-\\n');\n                    console.log(e);\n                });\n            });\n        }).return();\n    };\n    return HTTPCache;\n})();\nmodule.exports = HTTPCache;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/CacheStreamLoader.js":"'use strict';\nvar path = require('path');\nvar crypto = require('crypto');\nvar Promise = require('bluebird');\nvar joiAssert = require('joi-assert');\nvar zlib = require('zlib');\nvar request = require('request');\nvar es = require('event-stream');\nvar BufferList = require('bl');\nvar typeOf = require('../xm/typeOf');\nvar assert = require('../xm/assert');\nvar assertVar = require('../xm/assertVar');\nvar dateUtils = require('../xm/dateUtils');\nvar hash = require('../xm/hash');\nvar fileIO = require('../xm/fileIO');\nvar CacheObject = require('./CacheObject');\nvar ResponseInfo = require('./ResponseInfo');\nvar types = require('./types');\nvar CacheStreamLoader = (function () {\n    function CacheStreamLoader(opts, request) {\n        assertVar(opts, 'object', 'opts');\n        assertVar(request, 'object', 'request');\n        this.opts = opts;\n        this.request = request;\n        this.object = new CacheObject(this.request);\n        this.object.storeDir = fileIO.distributeDir(this.opts.cache.storeDir, this.request.key, this.opts.cache.splitDirLevel, this.opts.cache.splitDirChunk);\n        this.object.bodyFile = path.join(this.object.storeDir, this.request.key + '.raw');\n        this.object.infoFile = path.join(this.object.storeDir, this.request.key + '.json');\n    }\n    CacheStreamLoader.prototype.dropContent = function () {\n        this._promise = null;\n        var obj = new CacheObject(this.object.request);\n        obj.storeDir = this.object.storeDir;\n        obj.bodyFile = this.object.bodyFile;\n        obj.infoFile = this.object.infoFile;\n        this.object = obj;\n    };\n    Object.defineProperty(CacheStreamLoader.prototype, \"url\", {\n        get: function () {\n            return this.request ? this.request.url : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CacheStreamLoader.prototype.destruct = function () {\n        this._promise = null;\n    };\n    CacheStreamLoader.prototype.canUpdate = function () {\n        if (this.opts.cache.cacheRead && this.opts.cache.remoteRead && this.opts.cache.cacheWrite) {\n            return true;\n        }\n        return false;\n    };\n    CacheStreamLoader.prototype.getObject = function () {\n        var _this = this;\n        if (this._promise) {\n            return this._promise;\n        }\n        return this._promise = this.cacheRead().then(function () {\n            var useCached = false;\n            if (_this.object.body && _this.object.info) {\n                useCached = !_this.request.forceRefresh;\n                if (useCached && typeOf.isNumber(_this.request.httpInterval) && _this.opts.cache.cacheWrite) {\n                    if (new Date(_this.object.info.cacheUpdated).getTime() < Date.now() - _this.request.httpInterval) {\n                        useCached = false;\n                    }\n                }\n            }\n            if (useCached) {\n                return _this.cacheTouch().then(function () {\n                    return _this.object;\n                });\n            }\n            return _this.httpLoad(!_this.request.forceRefresh).then(function () {\n                if (!typeOf.isValid(_this.object.body)) {\n                    throw new Error('no result body: ' + _this.request.url + ' -> ' + _this.request.key);\n                }\n                return _this.object;\n            });\n        }).then(function () {\n            return _this.object;\n        }, function (err) {\n            _this.dropContent();\n            throw err;\n        });\n    };\n    CacheStreamLoader.prototype.cacheRead = function () {\n        var _this = this;\n        if (!this.opts.cache.cacheRead) {\n            return Promise.resolve();\n        }\n        return this.readInfo().then(function () {\n            if (!_this.object.info) {\n                throw new Error('no or invalid info object');\n            }\n            if (_this.opts.cache.remoteRead) {\n                if (typeOf.isNumber(_this.request.localMaxAge)) {\n                    var date = new Date(_this.object.info.cacheUpdated);\n                    var compare = new Date();\n                    assert(date.getTime() < compare.getTime() + _this.request.localMaxAge, 'date {a} vs {e}', date.toISOString(), compare.toISOString());\n                }\n            }\n            return fileIO.read(_this.object.bodyFile).then(function (buffer) {\n                if (buffer.length === 0) {\n                    throw new Error('empty body file');\n                }\n                _this.object.bodyChecksum = hash.sha1(buffer);\n                _this.object.body = buffer;\n            });\n        }).then(function () {\n            joiAssert(_this.object, types.objectSchema);\n            assert(_this.object.bodyChecksum === _this.object.info.contentChecksum, 'checksum {a} vs {e}', _this.object.info.contentChecksum, _this.object.bodyChecksum);\n            return _this.object;\n        }).catch(function (err) {\n            _this.dropContent();\n            return _this.cacheRemove().return(null);\n        });\n    };\n    CacheStreamLoader.prototype.httpLoad = function (httpCache) {\n        var _this = this;\n        if (httpCache === void 0) { httpCache = true; }\n        if (!this.opts.cache.remoteRead) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, reject) {\n            var req = {\n                url: _this.request.url,\n                headers: {}\n            };\n            if (_this.opts.proxy) {\n                req.proxy = _this.opts.proxy;\n            }\n            req.strictSSL = _this.opts.strictSSL;\n            Object.keys(_this.request.headers).forEach(function (key) {\n                req.headers[key] = String(_this.request.headers[key]);\n            });\n            if (_this.object.info && _this.object.body && httpCache) {\n                if (_this.object.info.httpETag) {\n                    req.headers['if-none-match'] = _this.object.info.httpETag;\n                }\n                if (_this.object.info.httpModified) {\n                    req.headers['if-modified-since'] = new Date(_this.object.info.httpModified).toUTCString();\n                }\n            }\n            req.headers['accept-encoding'] = 'gzip, deflate';\n            var pause = es.pause();\n            pause.pause();\n            var checkSha = crypto.createHash('sha1');\n            var r = request.get(req);\n            r.pipe(pause).on('error', function (err) {\n                reject(err);\n            });\n            r.on('response', function (res) {\n                _this.object.response = new ResponseInfo();\n                _this.object.response.status = res.statusCode;\n                _this.object.response.headers = res.headers;\n                if (res.statusCode < 200 || res.statusCode >= 400) {\n                    var errMsg = 'unexpected status code: ' + res.statusCode + ' on: ' + _this.request.url;\n                    if (res.statusCode === 403) {\n                        errMsg = 'EGITIHAPI, ' + errMsg;\n                    }\n                    reject(new Error(errMsg));\n                    return;\n                }\n                if (res.statusCode === 304) {\n                    if (!_this.object.body) {\n                        reject(new Error('flow error: http 304 but no local content on: ' + _this.request.url));\n                        return;\n                    }\n                    if (!_this.object.info) {\n                        reject(new Error('flow error: http 304 but no local info on: ' + _this.request.url));\n                        return;\n                    }\n                    _this.updateInfo(res, _this.object.info.contentChecksum);\n                    _this.cacheWrite(true).then(resolve, reject);\n                    return;\n                }\n                var writer = new BufferList(function (err, body) {\n                    if (!body) {\n                        throw new Error('flow error: http 304 but no local info on: ' + _this.request.url);\n                    }\n                    if (body.length === 0) {\n                        throw new Error('loaded zero bytes ' + _this.request.url);\n                    }\n                    var checksum = checkSha.digest('hex');\n                    if (_this.object.info) {\n                        _this.updateInfo(res, checksum);\n                    }\n                    else {\n                        _this.copyInfo(res, checksum);\n                    }\n                    _this.object.body = body;\n                    _this.cacheWrite(false).done(resolve, reject);\n                });\n                var decoded;\n                switch (res.headers['content-encoding']) {\n                    case 'gzip':\n                        decoded = pause.pipe(zlib.createGunzip());\n                        break;\n                    case 'deflate':\n                        decoded = pause.pipe(zlib.createInflate());\n                        break;\n                    default:\n                        decoded = pause;\n                        break;\n                }\n                decoded.on('data', function (chunk) {\n                    checkSha.update(chunk);\n                });\n                decoded.pipe(writer);\n                pause.resume();\n            });\n        });\n    };\n    CacheStreamLoader.prototype.cacheWrite = function (cacheWasFresh) {\n        var _this = this;\n        if (!this.opts.cache.cacheWrite) {\n            return Promise.resolve();\n        }\n        return Promise.try(function () {\n            if (_this.object.body.length === 0) {\n                throw new Error('wont write empty file to ' + _this.object.bodyFile);\n            }\n            var write = [];\n            if (!cacheWasFresh) {\n                write.push(fileIO.write(_this.object.bodyFile, _this.object.body));\n            }\n            write.push(fileIO.writeJSON(_this.object.infoFile, _this.object.info));\n            return Promise.all(write).then(function () {\n                return Promise.all([\n                    _this.checkExists(_this.object.bodyFile, 'body'),\n                    _this.checkExists(_this.object.infoFile, 'info')\n                ]);\n            }).then(function () {\n                return _this.cacheTouch();\n            });\n        });\n    };\n    CacheStreamLoader.prototype.checkExists = function (file, label) {\n        return fileIO.exists(file).then(function (exist) {\n            if (!exist) {\n                return Promise.resolve(false);\n            }\n            return fileIO.stat(file).then(function (stat) {\n                if (stat.size === 0) {\n                    return false;\n                }\n                return true;\n            }, function (e) { return false; });\n        });\n    };\n    CacheStreamLoader.prototype.cacheRemove = function () {\n        if (!this.canUpdate()) {\n            return Promise.resolve();\n        }\n        return Promise.all([\n            fileIO.removeFile(this.object.infoFile),\n            fileIO.removeFile(this.object.bodyFile),\n        ]).catch(function (e) { return null; }).return();\n    };\n    CacheStreamLoader.prototype.cacheTouch = function () {\n        if (!this.canUpdate()) {\n            return Promise.resolve();\n        }\n        return Promise.all([\n            fileIO.touchFile(this.object.infoFile),\n            fileIO.touchFile(this.object.bodyFile)\n        ]).catch(function (e) { return null; }).return();\n    };\n    CacheStreamLoader.prototype.readInfo = function () {\n        var _this = this;\n        return fileIO.isFile(this.object.infoFile).then(function (isFile) {\n            if (!isFile) {\n                return null;\n            }\n            return fileIO.readJSON(_this.object.infoFile).then(function (info) {\n                info = joiAssert(info, types.infoSchema);\n                assert((info.url === _this.request.url), 'info.url {a} is not {e}', info.url, _this.request.url);\n                assert((info.key === _this.request.key), 'info.key {a} is not {e}', info.key, _this.request.key);\n                _this.object.info = info;\n            });\n        });\n    };\n    CacheStreamLoader.prototype.copyInfo = function (res, checksum) {\n        var info = {};\n        info.url = this.request.url;\n        info.key = this.request.key;\n        info.contentType = res.headers['content-type'];\n        info.cacheCreated = dateUtils.getISOString(Date.now());\n        info.cacheUpdated = info.cacheCreated;\n        this.object.info = info;\n        this.updateInfo(res, checksum);\n    };\n    CacheStreamLoader.prototype.updateInfo = function (res, checksum) {\n        var info = this.object.info;\n        info.httpETag = (res.headers['etag'] || info.httpETag);\n        info.httpModified = dateUtils.getISOString((res.headers['last-modified'] ? new Date(res.headers['last-modified']) : new Date()));\n        info.cacheUpdated = dateUtils.getISOString(Date.now());\n        info.contentChecksum = checksum;\n    };\n    CacheStreamLoader.prototype.toString = function () {\n        return this.request ? this.request.url : '<no request>';\n    };\n    return CacheStreamLoader;\n})();\nmodule.exports = CacheStreamLoader;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/CacheObject.js":"'use strict';\nvar CacheObject = (function () {\n    function CacheObject(request) {\n        this.request = request;\n    }\n    return CacheObject;\n})();\nmodule.exports = CacheObject;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/ResponseInfo.js":"'use strict';\nvar ResponseInfo = (function () {\n    function ResponseInfo() {\n        this.status = 0;\n        this.headers = {};\n    }\n    return ResponseInfo;\n})();\nmodule.exports = ResponseInfo;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/types.js":"var Joi = require('joi');\nexports.manageSchema = Joi.object({\n    lastSweep: Joi.date().required()\n}).description('manageSchema');\nexports.infoSchema = Joi.object({\n    url: Joi.string().required(),\n    key: Joi.string().required(),\n    contentType: Joi.string().required(),\n    httpETag: Joi.string().required(),\n    httpModified: Joi.date().required(),\n    cacheCreated: Joi.date().required(),\n    cacheUpdated: Joi.date().required(),\n    contentChecksum: Joi.string().required()\n}).description('infoSchema');\nexports.sha1Schema = Joi.string().length(40).regex(/^[0-9a-f]{40}$/).description('sha1');\nexports.objectSchema = Joi.object({\n    info: exports.infoSchema.required(),\n    request: Joi.object().required(),\n    response: Joi.object().optional(),\n    body: Joi.binary(),\n    storeDir: Joi.string().required(),\n    bodyFile: Joi.string().required(),\n    infoFile: Joi.string().required(),\n    bodyChecksum: exports.sha1Schema.required()\n}).description('objectSchema');\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/http/CacheOpts.js":"'use strict';\nvar CacheMode = require('./CacheMode');\nvar CacheOpts = (function () {\n    function CacheOpts(mode) {\n        this.compressStore = false;\n        this.splitDirLevel = 0;\n        this.splitDirChunk = 1;\n        this.cacheRead = true;\n        this.cacheWrite = true;\n        this.remoteRead = true;\n        this.allowClean = false;\n        this.jobTimeout = 0;\n        if (mode) {\n            this.applyCacheMode(mode);\n        }\n    }\n    CacheOpts.prototype.applyCacheMode = function (mode) {\n        switch (mode) {\n            case CacheMode.forceRemote:\n                this.cacheRead = false;\n                this.remoteRead = true;\n                this.cacheWrite = false;\n                this.allowClean = false;\n                break;\n            case CacheMode.forceUpdate:\n                this.cacheRead = false;\n                this.remoteRead = true;\n                this.cacheWrite = true;\n                this.allowClean = true;\n                break;\n            case CacheMode.allowUpdate:\n                this.cacheRead = true;\n                this.remoteRead = true;\n                this.cacheWrite = true;\n                this.allowClean = true;\n                break;\n            case CacheMode.forceLocal:\n                this.cacheRead = true;\n                this.remoteRead = false;\n                this.cacheWrite = false;\n                this.allowClean = false;\n                break;\n            case CacheMode.allowRemote:\n            default:\n                this.cacheRead = true;\n                this.remoteRead = true;\n                this.cacheWrite = false;\n                this.allowClean = false;\n                break;\n        }\n    };\n    return CacheOpts;\n})();\nmodule.exports = CacheOpts;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/model/GithubRateInfo.js":"'use strict';\nvar typeOf = require('../../xm/typeOf');\nfunction pad(input) {\n    var r = String(input);\n    if (r.length === 1) {\n        r = '0' + r;\n    }\n    return r;\n}\nvar GithubRateInfo = (function () {\n    function GithubRateInfo(map) {\n        this.limit = 0;\n        this.remaining = 0;\n        this.resetAt = '';\n        this.readFromRes(map);\n    }\n    GithubRateInfo.prototype.readFromRes = function (map) {\n        if (typeOf.isObject(map)) {\n            if (map['x-ratelimit-limit']) {\n                this.limit = parseInt(map['x-ratelimit-limit'], 10);\n            }\n            if (map['x-ratelimit-remaining']) {\n                this.remaining = parseInt(map['x-ratelimit-remaining'], 10);\n            }\n            if (map['x-ratelimit-reset']) {\n                this.reset = parseInt(map['x-ratelimit-reset'], 10) * 1000;\n            }\n        }\n        this.lastUpdate = Date.now();\n        this.resetAt = this.getResetString();\n    };\n    GithubRateInfo.prototype.toString = function () {\n        return this.remaining + ' of ' + this.limit + (this.remaining < this.limit ? ' @ ' + this.getResetString() : '');\n    };\n    GithubRateInfo.prototype.getResetString = function () {\n        var time = this.getTimeToReset();\n        if (time > 0) {\n            time = time / 1000;\n            var hours = Math.floor(time / 3600);\n            time -= (hours * 3600);\n            var mins = Math.floor(time / 60);\n            var secs = Math.floor(time - (mins * 60));\n            return (hours) + ':' + pad(mins) + ':' + pad(secs);\n        }\n        if (this.limit > 0) {\n            return '<limit expired>';\n        }\n        return '<no known limit>';\n    };\n    GithubRateInfo.prototype.getTimeToReset = function () {\n        if (this.reset) {\n            return Math.max(0, this.reset - Date.now());\n        }\n        return 0;\n    };\n    GithubRateInfo.prototype.getMinutesToReset = function () {\n        if (this.reset) {\n            return Math.floor(this.getTimeToReset() / 1000 / 60);\n        }\n        return 0;\n    };\n    GithubRateInfo.prototype.isBlocked = function () {\n        return this.remaining === 0;\n    };\n    GithubRateInfo.prototype.isLimited = function () {\n        return this.limit > 0 && this.remaining < this.limit;\n    };\n    GithubRateInfo.prototype.hasRemaining = function () {\n        return this.remaining > 0;\n    };\n    return GithubRateInfo;\n})();\nmodule.exports = GithubRateInfo;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/loader/GithubRaw.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar assertVar = require('../../xm/assertVar');\nvar typeOf = require('../../xm/typeOf');\nvar CacheRequest = require('../../http/CacheRequest');\nvar GithubLoader = require('./GithubLoader');\nvar GithubRaw = (function (_super) {\n    __extends(GithubRaw, _super);\n    function GithubRaw(urls, options, shared, storeDir) {\n        _super.call(this, urls, options, shared, storeDir, 'GithubRaw');\n        this.formatVersion = '1.0';\n        this._initGithubLoader();\n    }\n    GithubRaw.prototype.getText = function (ref, filePath) {\n        return this.getFile(ref, filePath).then(function (buffer) {\n            return buffer.toString('utf8');\n        });\n    };\n    GithubRaw.prototype.getJSON = function (ref, filePath) {\n        return this.getFile(ref, filePath).then(function (buffer) {\n            return JSON.parse(buffer.toString('utf8'));\n        });\n    };\n    GithubRaw.prototype.getBinary = function (ref, filePath) {\n        return this.getFile(ref, filePath);\n    };\n    GithubRaw.prototype.getFile = function (ref, filePath) {\n        assertVar(filePath, 'string', 'filePath');\n        assertVar(ref, 'string', 'ref', true);\n        var url = this.urls.rawFile(ref, filePath);\n        var headers = {};\n        var request = new CacheRequest(url, headers);\n        if (typeOf.isSha(ref)) {\n            request.localMaxAge = this.options.getDurationSecs('localMaxAge') * 1000;\n            request.httpInterval = this.options.getDurationSecs('httpInterval') * 1000;\n        }\n        else {\n            request.localMaxAge = this.options.getDurationSecs('localMaxAge') * 1000;\n            request.httpInterval = this.options.getDurationSecs('httpIntervalRef') * 1000;\n        }\n        request.lock();\n        return this.cache.getObject(request).then(function (object) {\n            return object.body;\n        });\n    };\n    GithubRaw.prototype.getCacheKey = function () {\n        return 'git-raw-fmt' + this.formatVersion;\n    };\n    return GithubRaw;\n})(GithubLoader);\nmodule.exports = GithubRaw;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/IndexManager.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar pointer = require('json-pointer');\nvar VError = require('verror');\nvar Promise = require('bluebird');\nvar CoreModule = require('./CoreModule');\nvar DefIndex = require('../data/DefIndex');\nvar branch_tree = '/commit/commit/tree/sha';\nvar IndexManager = (function (_super) {\n    __extends(IndexManager, _super);\n    function IndexManager(core) {\n        _super.call(this, core, 'IndexManager');\n        this._promise = null;\n    }\n    IndexManager.prototype.getIndex = function () {\n        var _this = this;\n        if (this._promise) {\n            return this._promise;\n        }\n        return this._promise = this.core.repo.api.getBranch(this.core.context.config.ref).then(function (branchData) {\n            if (!branchData) {\n                throw new VError('loaded empty branch data');\n            }\n            var sha = pointer.get(branchData, branch_tree);\n            if (!sha) {\n                throw new VError('missing sha');\n            }\n            return _this.core.repo.api.getTree(sha, true).then(function (data) {\n                var index = new DefIndex();\n                index.init(branchData, data);\n                return index;\n            });\n        });\n    };\n    IndexManager.prototype.procureDef = function (path) {\n        return this.getIndex().then(function (index) {\n            var def = index.procureDef(path);\n            if (!def) {\n                throw new VError('cannot get def for path %s', path);\n            }\n            return def;\n        });\n    };\n    IndexManager.prototype.procureFile = function (path, commitSha) {\n        return this.getIndex().then(function (index) {\n            var file = index.procureVersionFromSha(path, commitSha);\n            if (!file) {\n                throw new VError('cannot get file for path %s', path);\n            }\n            return file;\n        });\n    };\n    IndexManager.prototype.procureCommit = function (commitSha) {\n        return this.getIndex().then(function (index) {\n            var commit = index.procureCommit(commitSha);\n            if (!commit) {\n                throw new VError('cannot commit def for commitSha %s', commitSha);\n            }\n            return commit;\n        });\n    };\n    IndexManager.prototype.findFile = function (path, commitShaFragment) {\n        return Promise.reject(new Error('implement me!'));\n    };\n    return IndexManager;\n})(CoreModule);\nmodule.exports = IndexManager;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/CoreModule.js":"'use strict';\nvar CoreModule = (function () {\n    function CoreModule(core, label) {\n        this.core = core;\n        this.label = label;\n    }\n    return CoreModule;\n})();\nmodule.exports = CoreModule;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/DefIndex.js":"'use strict';\nvar pointer = require('json-pointer');\nvar Lazy = require('lazy.js');\nvar VError = require('verror');\nvar assertVar = require('../../xm/assertVar');\nvar collection = require('../../xm/collection');\nvar Def = require('./Def');\nvar DefCommit = require('./DefCommit');\nvar DefVersion = require('./DefVersion');\nvar commit_sha = '/commit/sha';\nvar branch_tree_sha = '/commit/commit/tree/sha';\nvar DefIndex = (function () {\n    function DefIndex() {\n        this._branchName = null;\n        this._hasIndex = false;\n        this._indexCommit = null;\n        this._definitions = new collection.Hash();\n        this._commits = new collection.Hash();\n        this._versions = new collection.Hash();\n    }\n    DefIndex.prototype.hasIndex = function () {\n        return this._hasIndex;\n    };\n    DefIndex.prototype.init = function (branch, tree) {\n        var _this = this;\n        assertVar(branch, 'object', 'branch');\n        assertVar(tree, 'object', 'tree');\n        if (this._hasIndex) {\n            return;\n        }\n        this._commits.clear();\n        this._versions.clear();\n        this._definitions.clear();\n        assertVar(branch, 'object', 'branch');\n        assertVar(tree, 'object', 'tree');\n        var commitSha = pointer.get(branch, commit_sha);\n        var treeSha = tree.sha;\n        var sha = pointer.get(branch, branch_tree_sha);\n        assertVar(sha, 'string', 'sha');\n        assertVar(treeSha, 'string', 'treeSha');\n        assertVar(commitSha, 'string', 'commitSha');\n        if (sha !== treeSha) {\n            throw new VError('branch and tree sha mismatch');\n        }\n        this._branchName = branch.name;\n        this._indexCommit = this.procureCommit(commitSha);\n        this._indexCommit.parseJSON(branch.commit);\n        var def;\n        var file;\n        var releases = [];\n        Lazy(tree.tree).each(function (elem) {\n            var char = elem.path.charAt(0);\n            if (elem.type === 'blob' && char !== '.' && Def.isDefPath(elem.path)) {\n                def = _this.procureDef(elem.path);\n                if (!def) {\n                    return;\n                }\n                file = _this.procureVersion(def, _this._indexCommit);\n                if (!file) {\n                    return;\n                }\n                def.head = file;\n                file.setBlob(elem.sha);\n                if (def.isLegacy) {\n                    releases.push(def);\n                }\n            }\n        });\n        var defs = this._definitions.values();\n        releases.forEach(function (legacy) {\n            defs.some(function (def) {\n                if (def.project === legacy.project && def.name === legacy.name && def.isLegacy === false) {\n                    def.releases.push(legacy);\n                    return true;\n                }\n            });\n        });\n        this._hasIndex = true;\n    };\n    DefIndex.prototype.setHistory = function (def, commitJsonArray) {\n        var _this = this;\n        assertVar(def, Def, 'def');\n        assertVar(commitJsonArray, 'array', 'commits');\n        def.history = [];\n        Lazy(commitJsonArray).each(function (json) {\n            if (!json || !json.sha) {\n                console.dir(json, 'weird: json no sha', 1);\n            }\n            var commit = _this.procureCommit(json.sha);\n            if (!commit) {\n                console.dir('weird: no commit for sha ' + json.sha);\n                throw new VError('huh?');\n            }\n            if (!commit.hasMeta) {\n                commit.parseJSON(json);\n            }\n            def.history.push(_this.procureVersion(def, commit));\n        });\n    };\n    DefIndex.prototype.procureCommit = function (commitSha) {\n        assertVar(commitSha, 'sha1', 'commitSha');\n        var commit;\n        if (this._commits.has(commitSha)) {\n            commit = this._commits.get(commitSha);\n        }\n        else {\n            commit = new DefCommit(commitSha);\n            this._commits.set(commitSha, commit);\n        }\n        return commit;\n    };\n    DefIndex.prototype.procureDef = function (path) {\n        assertVar(path, 'string', 'path');\n        var def = null;\n        if (this._definitions.has(path)) {\n            def = this._definitions.get(path);\n        }\n        else {\n            def = new Def(path);\n            if (!def) {\n                throw new VError('cannot parse path to def %s', path);\n            }\n            this._definitions.set(path, def);\n        }\n        return def;\n    };\n    DefIndex.prototype.procureVersion = function (def, commit) {\n        assertVar(def, Def, 'def');\n        assertVar(commit, DefCommit, 'commit');\n        var file;\n        var key = def.path + '|' + commit.commitSha;\n        if (this._versions.has(key)) {\n            file = this._versions.get(key);\n            if (file.def !== def) {\n                throw new VError('weird: internal data mismatch: version does not belong to file %s -> %s', file.def, commit);\n            }\n        }\n        else {\n            file = new DefVersion(def, commit);\n            this._versions.set(key, file);\n        }\n        return file;\n    };\n    DefIndex.prototype.procureVersionFromSha = function (path, commitSha) {\n        assertVar(path, 'string', 'path');\n        assertVar(commitSha, 'sha1', 'commitSha');\n        var def = this.getDef(path);\n        if (!def) {\n            console.log('path not in index, attempt-adding: ' + path);\n            def = this.procureDef(path);\n        }\n        if (!def) {\n            throw new VError('cannot procure definition for %s', path);\n        }\n        var commit = this.procureCommit(commitSha);\n        if (!commit) {\n            throw new VError('cannot procure commit for %s -> %s', path, commitSha);\n        }\n        if (!commit.hasMetaData()) {\n        }\n        var file = this.procureVersion(def, commit);\n        if (!file) {\n            throw new VError('cannot procure definition version for %s -> %s', path, commit.commitSha);\n        }\n        return file;\n    };\n    DefIndex.prototype.getDef = function (path) {\n        return this._definitions.get(path);\n    };\n    DefIndex.prototype.hasDef = function (path) {\n        return this._definitions.has(path);\n    };\n    DefIndex.prototype.getCommit = function (sha) {\n        return this._commits.get(sha);\n    };\n    DefIndex.prototype.hasCommit = function (sha) {\n        return this._commits.has(sha);\n    };\n    DefIndex.prototype.getPaths = function () {\n        return this._definitions.values().map(function (file) {\n            return file.path;\n        });\n    };\n    DefIndex.prototype.toDump = function () {\n        var ret = [];\n        ret.push(this.toString());\n        this._definitions.forEach(function (def) {\n            ret.push('  ' + def.toString());\n        });\n        return ret.join('\\n') + '\\n' + 'total ' + this._definitions.size + ' definitions';\n    };\n    Object.defineProperty(DefIndex.prototype, \"branchName\", {\n        get: function () {\n            return this._branchName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DefIndex.prototype, \"list\", {\n        get: function () {\n            return this._definitions.values();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DefIndex.prototype, \"indexCommit\", {\n        get: function () {\n            return this._indexCommit;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DefIndex.prototype.toString = function () {\n        return '[' + this._branchName + ']';\n    };\n    return DefIndex;\n})();\nmodule.exports = DefIndex;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/SelectorQuery.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar VError = require('verror');\nvar defUtil = require('../util/defUtil');\nvar Selection = require('../select/Selection');\nvar VersionMatcher = require('../select/VersionMatcher');\nvar CoreModule = require('./CoreModule');\nvar SelectorQuery = (function (_super) {\n    __extends(SelectorQuery, _super);\n    function SelectorQuery(core) {\n        _super.call(this, core, 'Select');\n    }\n    SelectorQuery.prototype.select = function (query, options) {\n        var _this = this;\n        var res = new Selection(query);\n        return this.core.index.getIndex().then(function (index) {\n            res.definitions = query.patterns.reduce(function (memo, names) {\n                names.filter(index.list).forEach(function (def) {\n                    if (!defUtil.containsDef(memo, def)) {\n                        memo.push(def);\n                    }\n                });\n                return memo;\n            }, []);\n            if (query.versionMatcher) {\n                res.definitions = query.versionMatcher.filter(res.definitions);\n            }\n            else {\n                res.definitions = new VersionMatcher().filter(res.definitions);\n            }\n            res.selection = defUtil.getHeads(res.definitions);\n            if (options.minMatches > 0 && res.definitions.length < options.minMatches) {\n                throw new VError('expected more matches %s < %s', res.definitions.length, options.minMatches);\n            }\n            if (options.maxMatches > 0 && res.definitions.length > options.maxMatches) {\n                throw new VError('expected less matches %s > %s', res.definitions.length, options.maxMatches);\n            }\n        }).then(function () {\n            if (query.requiresHistory) {\n                if (options.limitApi > 0 && res.definitions.length > options.limitApi) {\n                    throw new VError('match count %s over api limit %s', res.definitions.length, options.limitApi);\n                }\n                return _this.core.content.loadHistoryBulk(res.definitions).then(function () {\n                    if (query.commitMatcher) {\n                        res.selection = [];\n                        res.definitions.forEach(function (def) {\n                            def.history = query.commitMatcher.filter(def.history);\n                            if (def.history.length > 0) {\n                                res.selection.push(defUtil.getLatest(def.history));\n                            }\n                        });\n                        res.definitions = defUtil.getDefs(res.selection);\n                    }\n                    if (query.dateMatcher) {\n                        res.selection = [];\n                        res.definitions.forEach(function (def) {\n                            def.history = query.dateMatcher.filter(def.history);\n                            if (def.history.length > 0) {\n                                res.selection.push(defUtil.getLatest(def.history));\n                            }\n                        });\n                        res.definitions = defUtil.getDefs(res.selection);\n                    }\n                });\n            }\n            return null;\n        }).then(function () {\n            if (query.parseInfo || query.infoMatcher) {\n                return _this.core.parser.parseDefInfoBulk(res.selection);\n            }\n            return null;\n        }).then(function () {\n            if (query.infoMatcher) {\n                res.selection = query.infoMatcher.filter(res.selection);\n                res.definitions = defUtil.getDefs(res.selection);\n            }\n        }).then(function () {\n            if (options.resolveDependencies) {\n                return _this.core.resolver.resolveBulk(res.selection);\n            }\n            return null;\n        }).return(res);\n    };\n    return SelectorQuery;\n})(CoreModule);\nmodule.exports = SelectorQuery;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/ConfigIO.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar VError = require('verror');\nvar fileIO = require('../../xm/fileIO');\nvar CoreModule = require('./CoreModule');\nvar ConfigIO = (function (_super) {\n    __extends(ConfigIO, _super);\n    function ConfigIO(core) {\n        _super.call(this, core, 'ConfigIO');\n    }\n    ConfigIO.prototype.initConfig = function (overwrite) {\n        var _this = this;\n        var target = this.core.context.paths.configFile;\n        return fileIO.exists(target).then(function (exists) {\n            if (exists) {\n                if (!overwrite) {\n                    throw new VError('cannot overwrite file %s', target);\n                }\n                return fileIO.remove(target);\n            }\n            return;\n        }).then(function () {\n            _this.core.context.config.reset();\n            return _this.saveConfig();\n        }).return(target);\n    };\n    ConfigIO.prototype.readConfig = function (optional) {\n        var _this = this;\n        if (optional === void 0) { optional = false; }\n        var target = this.core.context.paths.configFile;\n        return fileIO.exists(target).then(function (exists) {\n            if (!exists) {\n                if (!optional) {\n                    throw new VError('cannot locate file %s', target);\n                }\n                return;\n            }\n            return fileIO.read(target, { flags: 'r' }).then(function (json) {\n                _this.core.context.config.parseJSONString(String(json), target);\n                _this.core.updateConfig();\n            });\n        }).return();\n    };\n    ConfigIO.prototype.saveConfig = function (target) {\n        target = target || this.core.context.paths.configFile;\n        var output = this.core.context.config.toJSONString();\n        return fileIO.write(target, output).return(target);\n    };\n    return ConfigIO;\n})(CoreModule);\nmodule.exports = ConfigIO;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/ContentLoader.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Promise = require('bluebird');\nvar LRU = require('lru-cache');\nvar VError = require('verror');\nvar DefBlob = require('../data/DefBlob');\nvar defUtil = require('../util/defUtil');\nvar gitUtil = require('../../git/gitUtil');\nvar CoreModule = require('./CoreModule');\nvar ContentLoader = (function (_super) {\n    __extends(ContentLoader, _super);\n    function ContentLoader(core) {\n        _super.call(this, core, 'ContentLoader');\n        this.cache = LRU({\n            stale: true,\n            max: 10 * 1024 * 1024,\n            maxAge: 1000 * 60,\n            length: function (buffer) {\n                return buffer.length;\n            }\n        });\n    }\n    ContentLoader.prototype.loadCommitMetaData = function (commit) {\n        if (commit.hasMetaData()) {\n            return Promise.resolve(commit);\n        }\n        return this.core.repo.api.getCommit(commit.commitSha).then(function (json) {\n            commit.parseJSON(json);\n            return commit;\n        });\n    };\n    ContentLoader.prototype.loadContent = function (file, tryHead) {\n        var _this = this;\n        if (tryHead === void 0) { tryHead = true; }\n        if (file.blobSha && this.cache.has(file.blobSha)) {\n            return Promise.resolve(new DefBlob(file, this.cache.get(file.blobSha)));\n        }\n        var ref = file.commit.commitSha;\n        if (tryHead && file.def.head && file.commit.commitSha === file.def.head.commit.commitSha) {\n            ref = this.core.context.config.ref;\n        }\n        return this.core.repo.raw.getBinary(ref, file.def.path).then(function (content) {\n            var sha = gitUtil.blobShaHex(content);\n            if (file.blobSha) {\n                if (sha !== file.blobSha) {\n                    throw new VError('bad blob sha1 for %s, expected %s, got %s', file.def.path, file.blobSha, sha);\n                }\n            }\n            else {\n                file.setBlob(sha);\n            }\n            _this.cache.set(sha, content);\n            return new DefBlob(file, content);\n        });\n    };\n    ContentLoader.prototype.loadContentBulk = function (list) {\n        var _this = this;\n        return Promise.map(list, function (file) {\n            return _this.loadContent(file);\n        });\n    };\n    ContentLoader.prototype.loadHistory = function (def) {\n        if (def.history.length > 0) {\n            return Promise.resolve(def);\n        }\n        return Promise.all([\n            this.core.index.getIndex(),\n            this.core.repo.api.getPathCommits(def.path)\n        ]).spread(function (index, content) {\n            index.setHistory(def, content);\n        }).return(def);\n    };\n    ContentLoader.prototype.loadHistoryBulk = function (list) {\n        var _this = this;\n        list = defUtil.uniqueDefs(list);\n        return Promise.map(list, function (file) {\n            return _this.loadHistory(file);\n        });\n    };\n    return ContentLoader;\n})(CoreModule);\nmodule.exports = ContentLoader;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/DefBlob.js":"'use strict';\nvar assertVar = require('../../xm/assertVar');\nvar DefVersion = require('./DefVersion');\nvar DefBlob = (function () {\n    function DefBlob(file, buffer) {\n        assertVar(file, DefVersion, 'file');\n        assertVar(buffer, Buffer, 'buffer');\n        this.file = file;\n        this.content = buffer;\n        Object.freeze(this);\n    }\n    return DefBlob;\n})();\nmodule.exports = DefBlob;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/git/gitUtil.js":"'use strict';\nvar assertVar = require('../xm/assertVar');\nvar crypto = require('crypto');\nfunction decodeBlobJson(blobJSON) {\n    if (!blobJSON || !blobJSON.encoding) {\n        return null;\n    }\n    switch (blobJSON.encoding) {\n        case 'base64':\n            return new Buffer(blobJSON.content, 'base64');\n        case 'utf-8':\n        case 'utf8':\n        default:\n            return new Buffer(blobJSON.content, 'utf8');\n    }\n}\nexports.decodeBlobJson = decodeBlobJson;\nfunction blobShaHex(data) {\n    assertVar(data, Buffer, 'data');\n    return crypto.createHash('sha1').update('blob ' + data.length + '\\0').update(data).digest('hex');\n}\nexports.blobShaHex = blobShaHex;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/InfoParser.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar Promise = require('bluebird');\nvar header = require('definition-header');\nvar CoreModule = require('./CoreModule');\nvar DefInfo = require('../data/DefInfo');\nvar defUtil = require('../util/defUtil');\nvar AuthorInfo = require('../support/AuthorInfo');\nvar InfoParser = (function (_super) {\n    __extends(InfoParser, _super);\n    function InfoParser(core) {\n        _super.call(this, core, 'InfoParser');\n    }\n    InfoParser.prototype.parseDefInfo = function (file) {\n        return this.core.content.loadContent(file).then(function (blob) {\n            var source = blob.content.toString('utf8');\n            if (file.info) {\n                file.info.resetFields();\n            }\n            else {\n                file.info = new DefInfo();\n            }\n            file.info.externals = defUtil.extractExternals(source);\n            if (header.isPartial(source)) {\n                file.info.partial = true;\n                return file;\n            }\n            var res = header.parse(source);\n            if (res.success) {\n                var head = res.value;\n                file.info.name = head.label.name;\n                file.info.version = (head.label.version || '');\n                file.info.projects = head.project.map(function (p) { return p.url; });\n                file.info.authors = head.authors.map(function (a) {\n                    return new AuthorInfo(a.name, a.url);\n                });\n            }\n            return file;\n        });\n    };\n    InfoParser.prototype.parseDefInfoBulk = function (list) {\n        var _this = this;\n        list = defUtil.uniqueDefVersion(list);\n        return Promise.map(list, function (file) {\n            return _this.parseDefInfo(file);\n        });\n    };\n    return InfoParser;\n})(CoreModule);\nmodule.exports = InfoParser;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/data/DefInfo.js":"'use strict';\nvar DefInfo = (function () {\n    function DefInfo() {\n        this.externals = [];\n        this.resetAll();\n    }\n    DefInfo.prototype.resetFields = function () {\n        this.name = '';\n        this.version = '';\n        this.projects = [];\n        this.authors = [];\n    };\n    DefInfo.prototype.resetAll = function () {\n        this.resetFields();\n    };\n    DefInfo.prototype.toString = function () {\n        return this.name;\n    };\n    DefInfo.prototype.isValid = function () {\n        if (!this.name) {\n            return false;\n        }\n        return true;\n    };\n    return DefInfo;\n})();\nmodule.exports = DefInfo;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/AuthorInfo.js":"'use strict';\nvar trim = /\\/$/;\nvar AuthorInfo = (function () {\n    function AuthorInfo(name, url, email) {\n        if (name === void 0) { name = ''; }\n        if (url === void 0) { url = null; }\n        if (email === void 0) { email = null; }\n        this.name = name;\n        this.url = url;\n        this.email = email;\n        if (this.url) {\n            this.url = this.url.replace(trim, '');\n        }\n    }\n    AuthorInfo.prototype.toString = function () {\n        return this.name + (this.email ? ' @ ' + this.email : '') + (this.url ? ' <' + this.url + '>' : '');\n    };\n    AuthorInfo.prototype.toJSON = function () {\n        var obj = {\n            name: this.name\n        };\n        if (this.url) {\n            obj.url = this.url;\n        }\n        if (this.email) {\n            obj.email = this.email;\n        }\n        return obj;\n    };\n    return AuthorInfo;\n})();\nmodule.exports = AuthorInfo;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/Installer.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar path = require('path');\nvar Promise = require('bluebird');\nvar collection = require('../../xm/collection');\nvar fileIO = require('../../xm/fileIO');\nvar CoreModule = require('./CoreModule');\nvar defUtil = require('../util/defUtil');\nvar Installer = (function (_super) {\n    __extends(Installer, _super);\n    function Installer(core) {\n        _super.call(this, core, 'Installer');\n    }\n    Installer.prototype.getInstallPath = function (def) {\n        return path.join(this.core.context.getTypingsDir(), def.path.replace(/[//\\/]/g, path.sep));\n    };\n    Installer.prototype.installFile = function (file, addToConfig, overwrite) {\n        var _this = this;\n        if (addToConfig === void 0) { addToConfig = true; }\n        if (overwrite === void 0) { overwrite = false; }\n        return this.useFile(file, overwrite).then(function (targetPath) {\n            if (targetPath) {\n                if (_this.core.context.config.hasFile(file.def.path)) {\n                    _this.core.context.config.getFile(file.def.path).update(file);\n                }\n                else if (addToConfig) {\n                    _this.core.context.config.addFile(file);\n                }\n            }\n            return targetPath;\n        });\n    };\n    Installer.prototype.installFileBulk = function (list, addToConfig, overwrite) {\n        var _this = this;\n        if (addToConfig === void 0) { addToConfig = true; }\n        if (overwrite === void 0) { overwrite = true; }\n        var written = new collection.Hash();\n        return Promise.map(list, function (file) {\n            return _this.installFile(file, addToConfig, overwrite).then(function (targetPath) {\n                if (targetPath) {\n                    written.set(file.def.path, file);\n                }\n            });\n        }).return(written);\n    };\n    Installer.prototype.reinstallBulk = function (list, overwrite) {\n        var _this = this;\n        if (overwrite === void 0) { overwrite = false; }\n        var written = new collection.Hash();\n        return Promise.map(list, function (installed) {\n            return _this.core.index.procureFile(installed.path, installed.commitSha).then(function (file) {\n                return _this.installFile(file, true, overwrite).then(function (targetPath) {\n                    if (targetPath) {\n                        written.set(file.def.path, file);\n                    }\n                    return file;\n                });\n            });\n        }).return(written);\n    };\n    Installer.prototype.removeUnusedReferences = function (list, typingsPath) {\n        var removed = [];\n        var fnFoundDefDir = function (dir) {\n            for (var i = 0; i < list.length; i++) {\n                var baseName = path.dirname(list[i].path).split('/')[0];\n                if (baseName === dir) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        fileIO.getDirNameList(typingsPath).forEach(function (dir) {\n            if (!fnFoundDefDir(dir)) {\n                fileIO.removeDirSync(path.join(typingsPath, dir));\n                removed.push(path.join(typingsPath, dir));\n            }\n        });\n        fileIO.removeAllFilesFromDir(typingsPath);\n        return Promise.all([]).return(removed);\n    };\n    Installer.prototype.useFile = function (file, overwrite) {\n        var _this = this;\n        var targetPath = this.getInstallPath(file.def);\n        return fileIO.canWriteFile(targetPath, overwrite).then(function (canWrite) {\n            if (!canWrite) {\n                if (!overwrite) {\n                }\n                return null;\n            }\n            return _this.core.content.loadContent(file).then(function (blob) {\n                return fileIO.write(targetPath, blob.content);\n            }).return(targetPath);\n        });\n    };\n    Installer.prototype.useFileBulk = function (list, overwrite) {\n        var _this = this;\n        if (overwrite === void 0) { overwrite = true; }\n        list = defUtil.uniqueDefVersion(list);\n        var written = new collection.Hash();\n        return Promise.map(list, function (file) {\n            return _this.useFile(file, overwrite).then(function (targetPath) {\n                if (targetPath) {\n                    written.set(file.def.path, file);\n                }\n            });\n        }).return(written);\n    };\n    return Installer;\n})(CoreModule);\nmodule.exports = Installer;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/logic/Resolver.js":"'use strict';\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar path = require('path');\nvar Promise = require('bluebird');\nvar collection = require('../../xm/collection');\nvar Def = require('../data/Def');\nvar defUtil = require('../util/defUtil');\nvar CoreModule = require('./CoreModule');\nvar localExp = /^\\.\\//;\nvar leadingExp = /^\\.\\.\\//;\nvar Resolver = (function (_super) {\n    __extends(Resolver, _super);\n    function Resolver(core) {\n        _super.call(this, core, 'Resolver');\n        this._active = new collection.Hash();\n    }\n    Resolver.prototype.resolveBulk = function (list) {\n        var _this = this;\n        list = defUtil.uniqueDefVersion(list);\n        return Promise.map(list, function (file) {\n            return _this.resolveDeps(file);\n        }).return(list);\n    };\n    Resolver.prototype.resolveDeps = function (file) {\n        var _this = this;\n        if (file.solved) {\n            return Promise.resolve(file);\n        }\n        if (this._active.has(file.key)) {\n            return this._active.get(file.key);\n        }\n        var promise = Promise.all([\n            this.core.index.getIndex(),\n            this.core.content.loadContent(file)\n        ]).spread(function (index, blob) {\n            file.dependencies.splice(0, file.dependencies.length);\n            var queued = _this.applyResolution(index, file, blob.content.toString());\n            file.solved = true;\n            return Promise.all(queued);\n        }).finally(function () {\n            _this._active.delete(file.key);\n        }).return(file);\n        this._active.set(file.key, promise);\n        return promise;\n    };\n    Resolver.prototype.applyResolution = function (index, file, content) {\n        var _this = this;\n        var refs = this.extractPaths(file, content);\n        return refs.reduce(function (memo, refPath) {\n            if (index.hasDef(refPath)) {\n                var dep = index.getDef(refPath);\n                file.dependencies.push(dep);\n                if (!dep.head.solved && !_this._active.has(dep.head.key)) {\n                    memo.push(_this.resolveDeps(dep.head));\n                }\n            }\n            else {\n                console.log('path reference not in index: ' + refPath);\n            }\n            return memo;\n        }, []);\n    };\n    Resolver.prototype.extractPaths = function (file, content) {\n        return defUtil.extractReferenceTags(content).reduce(function (memo, refPath) {\n            refPath = path.normalize(path.dirname(file.def.path) + '/' + refPath).replace(/\\\\/g, '/');\n            if (Def.isDefPath(refPath) && memo.indexOf(refPath) < 0) {\n                memo.push(refPath);\n            }\n            return memo;\n        }, []);\n    };\n    return Resolver;\n})(CoreModule);\nmodule.exports = Resolver;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/PackageLinker.js":"'use strict';\nvar path = require('path');\nvar Promise = require('bluebird');\nvar FS = require('../../xm/fileIO');\nvar typeOf = require('../../xm/typeOf');\nvar PackageDefinition = require('../support/PackageDefinition');\nvar PackageType = (function () {\n    function PackageType(name, folderName, packageGlob, infoJson) {\n        this.name = name;\n        this.folderName = folderName;\n        this.packageGlob = packageGlob;\n        this.infoJson = infoJson;\n    }\n    return PackageType;\n})();\nfunction getStringArray(elem) {\n    if (!typeOf.isArray(elem)) {\n        if (typeOf.isString(elem)) {\n            return [elem];\n        }\n        return [];\n    }\n    return elem.filter(typeOf.isString);\n}\nvar PackageLinker = (function () {\n    function PackageLinker() {\n        this.managers = [];\n        this.managers.push(new PackageType('node', 'node_modules', '{*/,@*/*/}', 'package.json'));\n        this.managers.push(new PackageType('bower', 'bower_components', '*/', 'bower.json'));\n    }\n    PackageLinker.prototype.scanDefinitions = function (baseDir) {\n        var _this = this;\n        var memo = [];\n        return Promise.all(this.managers.map(function (type) {\n            return _this.scanFolder(memo, type, baseDir);\n        })).return(memo);\n    };\n    PackageLinker.prototype.scanFolder = function (memo, type, baseDir) {\n        var scanDir = path.resolve(baseDir, type.folderName);\n        var pattern = type.packageGlob + type.infoJson;\n        return FS.glob(pattern, {\n            cwd: scanDir\n        }).map(function (infoPath) {\n            var packageName = path.dirname(infoPath);\n            infoPath = path.join(scanDir, infoPath);\n            return FS.readJSON(infoPath).then(function (info) {\n                var use = new PackageDefinition(packageName, [], type.name);\n                return Promise.all(PackageLinker.extractDefLinks(info).map(function (ref) {\n                    ref = path.resolve(path.dirname(infoPath), ref);\n                    return FS.exists(ref).then(function (exists) {\n                        if (exists) {\n                            use.definitions.push(ref);\n                        }\n                    });\n                })).then(function () {\n                    if (use.definitions.length > 0) {\n                        memo.push(use);\n                    }\n                });\n            }).return();\n        }).catch(function (err) {\n        });\n    };\n    PackageLinker.extractDefLinks = function (object) {\n        var ret = [];\n        if (!typeOf.isObject(object)) {\n            return ret;\n        }\n        if (!typeOf.hasOwnProp(object, 'typescript')) {\n            return ret;\n        }\n        var ts = object.typescript;\n        if (!typeOf.isObject(ts)) {\n            return ret;\n        }\n        if (typeOf.hasOwnProp(ts, 'definition')) {\n            return getStringArray(ts.definition);\n        }\n        if (typeOf.hasOwnProp(ts, 'definitions')) {\n            return getStringArray(ts.definitions);\n        }\n        return ret;\n    };\n    return PackageLinker;\n})();\nmodule.exports = PackageLinker;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/PackageDefinition.js":"var assertVar = require('../../xm/assertVar');\nvar PackageDefinition = (function () {\n    function PackageDefinition(name, definitions, manager) {\n        assertVar(name, 'string', name);\n        assertVar(definitions, 'array', 'definitions');\n        assertVar(manager, 'string', 'manager', true);\n        this.name = name;\n        this.definitions = definitions || [];\n        this.manager = manager || 'unknown';\n    }\n    return PackageDefinition;\n})();\nmodule.exports = PackageDefinition;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/BundleManager.js":"'use strict';\nvar path = require('path');\nvar Promise = require('bluebird');\nvar VError = require('verror');\nvar fileIO = require('../../xm/fileIO');\nvar Bundle = require('../support/Bundle');\nvar BundleChange = require('../support/BundleChange');\nvar BundleManager = (function () {\n    function BundleManager(typingsDir) {\n        this.typingsDir = typingsDir;\n    }\n    BundleManager.prototype.addToBundle = function (target, refs, save) {\n        var _this = this;\n        return this.readBundle(target, true).then(function (bundle) {\n            var change = new BundleChange(bundle);\n            refs.forEach(function (ref) {\n                change.add(bundle.append(ref));\n            });\n            if (save && change.someAdded()) {\n                return _this.saveBundle(bundle).return(change);\n            }\n            return Promise.resolve(change);\n        });\n    };\n    BundleManager.prototype.readBundle = function (target, optional) {\n        target = path.resolve(target);\n        var bundle = new Bundle(target, this.typingsDir);\n        return fileIO.exists(target).then(function (exists) {\n            if (!exists) {\n                if (!optional) {\n                    throw new VError('cannot locate file %s', target);\n                }\n                return Promise.resolve(bundle);\n            }\n            return fileIO.read(target, { flags: 'rb' }).then(function (buffer) {\n                bundle.parse(buffer.toString('utf8'));\n            }).return(bundle);\n        });\n    };\n    BundleManager.prototype.cleanupBundle = function (target, save) {\n        var _this = this;\n        target = path.resolve(target);\n        return this.readBundle(target, true).then(function (bundle) {\n            var change = new BundleChange(bundle);\n            return Promise.map(bundle.toArray(), function (full) {\n                return fileIO.exists(full).then(function (exists) {\n                    if (!exists) {\n                        change.remove(bundle.remove(full));\n                    }\n                });\n            }).then(function () {\n                if (save && change.someRemoved()) {\n                    return _this.saveBundle(bundle);\n                }\n                return Promise.resolve();\n            }).return(change);\n        });\n    };\n    BundleManager.prototype.updateBundle = function (target, save) {\n        var _this = this;\n        target = path.resolve(target);\n        return this.cleanupBundle(target, false).then(function (change) {\n            return fileIO.glob('*/*.d.ts', {\n                cwd: change.bundle.baseDir\n            }).then(function (paths) {\n                paths.forEach(function (def) {\n                    var full = path.resolve(change.bundle.baseDir, def);\n                    change.add(change.bundle.append(full));\n                });\n                if (save && change.someChanged()) {\n                    return _this.saveBundle(change.bundle);\n                }\n                return Promise.resolve();\n            }).return(change);\n        });\n    };\n    BundleManager.prototype.saveBundle = function (bundle) {\n        var target = path.resolve(bundle.target);\n        return fileIO.write(target, bundle.stringify());\n    };\n    BundleManager.prototype.saveEmptyBundle = function (target) {\n        target = path.resolve(target);\n        return fileIO.exists(target).then(function (exists) {\n            if (!exists) {\n                return fileIO.write(target, '\\n');\n            }\n        });\n    };\n    return BundleManager;\n})();\nmodule.exports = BundleManager;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/Bundle.js":"'use strict';\nvar path = require('path');\nvar Lazy = require('lazy.js');\nvar assertVar = require('../../xm/assertVar');\nvar splitExp = /(?:(.*)(\\r?\\n))|(?:(.+)($))/g;\nvar referenceTagExp = /\\/\\/\\/[ \\t]+<reference[ \\t]*path=[\"']?([\\w\\.\\/@_-]*)[\"']?[ \\t]*\\/>/g;\nfunction fixWinDrive(ref) {\n    return ref.replace(/^[a-z]:/, function (str) {\n        return str.toUpperCase();\n    });\n}\nvar Bundle = (function () {\n    function Bundle(target, baseDir) {\n        this.lines = [];\n        this.last = null;\n        this.map = Object.create(null);\n        this.eol = '\\n';\n        assertVar(target, 'string', 'target');\n        this.target = fixWinDrive(target.replace(/^\\.\\//, ''));\n        this.baseDir = fixWinDrive(baseDir || path.dirname(this.target));\n    }\n    Bundle.prototype.parse = function (content) {\n        this.eol = '\\n';\n        var lineMatch;\n        var refMatch;\n        var line;\n        var eolWin = 0;\n        var eolNix = 0;\n        splitExp.lastIndex = 0;\n        while ((lineMatch = splitExp.exec(content))) {\n            splitExp.lastIndex = lineMatch.index + lineMatch[0].length;\n            line = new BundleLine(lineMatch[1]);\n            this.lines.push(line);\n            if (/\\r\\n/.test(lineMatch[2])) {\n                eolWin++;\n            }\n            else {\n                eolNix++;\n            }\n            referenceTagExp.lastIndex = 0;\n            refMatch = referenceTagExp.exec(lineMatch[1]);\n            if (refMatch && refMatch.length > 1) {\n                line.ref = fixWinDrive(path.resolve(this.baseDir, refMatch[1]));\n                this.map[line.ref] = line;\n                this.last = line;\n            }\n        }\n        this.eol = (eolWin > eolNix ? '\\r\\n' : '\\n');\n    };\n    Bundle.prototype.has = function (ref) {\n        ref = fixWinDrive(path.resolve(this.baseDir, ref));\n        return (ref in this.map);\n    };\n    Bundle.prototype.append = function (ref) {\n        ref = fixWinDrive(path.resolve(this.baseDir, ref));\n        if (!(ref in this.map)) {\n            var line = new BundleLine('', ref);\n            this.map[ref] = line;\n            if (this.last) {\n                var i = this.lines.indexOf(this.last);\n                if (i > -1) {\n                    this.lines.splice(i + 1, 0, line);\n                    this.last = line;\n                    return ref;\n                }\n            }\n            this.lines.push(line);\n            this.last = line;\n            return ref;\n        }\n        return null;\n    };\n    Bundle.prototype.remove = function (ref) {\n        ref = fixWinDrive(path.resolve(this.baseDir, ref));\n        if (ref in this.map) {\n            var line = this.map[ref];\n            var i = this.lines.indexOf(line);\n            if (i > -1) {\n                this.lines.splice(i, 1);\n            }\n            delete this.map[ref];\n            if (line === this.last) {\n                for (i -= 1; i >= 0; i--) {\n                    if (this.lines[i].ref) {\n                        this.last = this.lines[i];\n                        return ref;\n                    }\n                }\n            }\n            this.last = null;\n            return ref;\n        }\n        return null;\n    };\n    Bundle.prototype.toArray = function (relative, canonical) {\n        if (relative === void 0) { relative = false; }\n        if (canonical === void 0) { canonical = false; }\n        var base = (relative ? path.dirname(this.target) : null);\n        return Lazy(this.lines)\n            .filter(function (line) { return !!line.ref; })\n            .map(function (line) { return line.getRef(base, canonical); })\n            .toArray();\n    };\n    Bundle.prototype.stringify = function () {\n        var _this = this;\n        var base = path.dirname(this.target);\n        return this.lines.map(function (line) {\n            return line.getValue(base) + _this.eol;\n        }).join('');\n    };\n    return Bundle;\n})();\nvar BundleLine = (function () {\n    function BundleLine(value, ref) {\n        this.value = value;\n        this.ref = ref;\n    }\n    BundleLine.prototype.getRef = function (base, canonical) {\n        var ref = this.ref;\n        if (base) {\n            ref = path.relative(base, ref);\n        }\n        if (canonical && path.sep === '\\\\') {\n            ref = ref.replace(/\\\\/g, '/');\n        }\n        return ref;\n    };\n    BundleLine.prototype.getValue = function (base) {\n        if (this.ref) {\n            return '/// <reference path=\"' + this.getRef(base, true) + '\" />';\n        }\n        return this.value;\n    };\n    return BundleLine;\n})();\nmodule.exports = Bundle;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/support/BundleChange.js":"'use strict';\nvar path = require('path');\nvar collection = require('../../xm/collection');\nvar BundleChange = (function () {\n    function BundleChange(bundle) {\n        this._added = new collection.Set();\n        this._removed = new collection.Set();\n        this.bundle = bundle;\n    }\n    BundleChange.prototype.add = function (target) {\n        if (!target) {\n            return;\n        }\n        this._added.add(target);\n        this._removed.delete(target);\n    };\n    BundleChange.prototype.remove = function (target) {\n        if (!target) {\n            return;\n        }\n        this._added.delete(target);\n        this._removed.add(target);\n    };\n    BundleChange.prototype.someRemoved = function () {\n        return this._removed.size > 0;\n    };\n    BundleChange.prototype.someAdded = function () {\n        return this._added.size > 0;\n    };\n    BundleChange.prototype.someChanged = function () {\n        return this._added.size > 0 || this._removed.size > 0;\n    };\n    BundleChange.prototype.getRemoved = function (relative, canonical) {\n        var _this = this;\n        if (canonical === void 0) { canonical = false; }\n        var arr = this._removed.values();\n        if (!relative) {\n            arr = arr.map(function (p) { return path.resolve(_this.bundle.baseDir, p); });\n        }\n        else {\n            arr = arr.map(function (p) { return path.relative(_this.bundle.baseDir, p); });\n        }\n        if (canonical) {\n            return arr.map(function (p) { return p.replace(/\\\\/g, '/'); });\n        }\n        return arr;\n    };\n    BundleChange.prototype.getAdded = function (relative, canonical) {\n        var _this = this;\n        if (canonical === void 0) { canonical = false; }\n        var arr = this._added.values();\n        if (!relative) {\n            arr = arr.map(function (p) { return path.resolve(_this.bundle.baseDir, p); });\n        }\n        else {\n            arr = arr.map(function (p) { return path.relative(_this.bundle.baseDir, p); });\n        }\n        if (canonical) {\n            return arr.map(function (p) { return p.replace(/\\\\/g, '/'); });\n        }\n        return arr;\n    };\n    return BundleChange;\n})();\nmodule.exports = BundleChange;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/CommitMatcher.js":"'use strict';\nvar assert = require('../../xm/assert');\nvar fullSha = /^[0-9a-f]{40}$/;\nvar hex = /^[0-9a-f]+$/;\nvar CommitMatcher = (function () {\n    function CommitMatcher(commitSha) {\n        this.minimumShaLen = 2;\n        if (commitSha) {\n            this.commitSha = String(commitSha).toLowerCase();\n        }\n    }\n    CommitMatcher.prototype.filter = function (list) {\n        if (!this.commitSha) {\n            return list;\n        }\n        return list.filter(this.getFilterFunc(this.commitSha));\n    };\n    CommitMatcher.prototype.getFilterFunc = function (commitSha) {\n        if (fullSha.test(commitSha)) {\n            return function (file) {\n                return (file.commit && file.commit.commitSha === commitSha);\n            };\n        }\n        assert(hex.test(commitSha), 'parameter not a hex {a}', commitSha);\n        var len = commitSha.length;\n        assert((len >= this.minimumShaLen), 'parameter hex too short: expected {e}, got {a}', this.minimumShaLen, len);\n        return function (file) {\n            return (file.commit && file.commit.commitSha.substr(0, len) === commitSha);\n        };\n    };\n    return CommitMatcher;\n})();\nmodule.exports = CommitMatcher;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/DateMatcher.js":"'use strict';\nvar typeOf = require('../../xm/typeOf');\nvar assert = require('../../xm/assert');\nvar assertVar = require('../../xm/assertVar');\nvar dateUtils = require('../../xm/dateUtils');\nvar DateComp = require('../util/DateComp');\nvar defUtil = require('../util/defUtil');\nvar termExp = /(>=?|<=?|==) *(\\d+[\\d:;_ \\-]+\\d)/g;\nvar comparators = {\n    '<=': function lte(date1, date2) {\n        return dateUtils.isBeforeDate(date1, date2) || dateUtils.isEqualDate(date1, date2);\n    },\n    '<': dateUtils.isBeforeDate,\n    '>=': function gte(date1, date2) {\n        return dateUtils.isAfterDate(date1, date2) || dateUtils.isEqualDate(date1, date2);\n    },\n    '>': dateUtils.isAfterDate,\n    '==': dateUtils.isEqualDate\n};\nvar DateMatcher = (function () {\n    function DateMatcher(pattern) {\n        this.comparators = [];\n        if (pattern) {\n            this.extractSelector(pattern);\n        }\n    }\n    DateMatcher.prototype.filter = function (list) {\n        if (this.comparators.length === 0) {\n            return list;\n        }\n        return list.filter(this.getFilterFunc());\n    };\n    DateMatcher.prototype.best = function (list) {\n        return this.latest(this.filter(list));\n    };\n    DateMatcher.prototype.latest = function (list) {\n        if (this.comparators.length > 0) {\n            var list = this.filter(list).sort(defUtil.fileCommitCompare);\n            if (list.length > 0) {\n                return list[list.length - 1];\n            }\n        }\n        return null;\n    };\n    DateMatcher.prototype.extractSelector = function (pattern) {\n        assertVar(pattern, 'string', 'pattern');\n        this.comparators = [];\n        if (!pattern) {\n            return;\n        }\n        termExp.lastIndex = 0;\n        var match;\n        while ((match = termExp.exec(pattern))) {\n            termExp.lastIndex = match.index + match[0].length;\n            assert(typeOf.hasOwnProp(comparators, match[1]), 'not a valid date comparator in filter {a}', match[0]);\n            var comp = new DateComp();\n            comp.date = new Date(match[2].replace(/;_/g, ' '));\n            assert(!!comp.date, 'not a valid date in filter {a}', match[0]);\n            comp.operator = match[1];\n            comp.comparator = comparators[match[1]];\n            this.comparators.push(comp);\n        }\n    };\n    DateMatcher.prototype.getFilterFunc = function () {\n        var _this = this;\n        var len = this.comparators.length;\n        return function (file) {\n            var date = file.commit.changeDate;\n            if (!date) {\n                return false;\n            }\n            for (var i = 0; i < len; i++) {\n                if (!_this.comparators[i].satisfies(date)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    };\n    return DateMatcher;\n})();\nmodule.exports = DateMatcher;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/util/DateComp.js":"'use strict';\nvar DateComp = (function () {\n    function DateComp() {\n    }\n    DateComp.prototype.satisfies = function (date) {\n        return this.comparator(date, this.date);\n    };\n    return DateComp;\n})();\nmodule.exports = DateComp;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/tsd/select/InfoMatcher.js":"'use strict';\nvar InfoMatcher = (function () {\n    function InfoMatcher() {\n    }\n    InfoMatcher.prototype.filter = function (list) {\n        return list;\n    };\n    return InfoMatcher;\n})();\nmodule.exports = InfoMatcher;\n","/home/travis/build/npmtest/node-npmtest-tsd/node_modules/tsd/build/getContent.js":"'use strict';\nvar path = require('path');\nvar tsd = require('./api');\nfunction getAPI(options) {\n    var api = tsd.getAPI(options.config, options.verbose);\n    if (options.cacheDir) {\n        api.context.paths.cacheDir = path.resolve(options.cacheDir);\n    }\n    return api;\n}\nfunction getContent(options) {\n    var api = getAPI(options);\n    return api.readConfig(false).then(function () {\n        var opts = new tsd.Options();\n        opts.resolveDependencies = false;\n        var query = new tsd.Query();\n        query.addNamePattern('*');\n        query.setVersionRange('all');\n        query.parseInfo = true;\n        return api.select(query, opts);\n    }).then(function (selection) {\n        return selection.definitions.filter(function (def) {\n            return !def.isLegacy && def.isMain;\n        }).sort(tsd.defUtil.defCompare).map(function (def) {\n            var ret = {\n                project: def.project,\n                name: def.name,\n                path: def.path,\n                semver: (def.semver || 'latest')\n            };\n            if (def.head.info) {\n                ret.info = def.head.info;\n            }\n            if (def.head.dependencies) {\n                ret.dependencies = def.head.dependencies.map(function (dep) {\n                    var ret = {\n                        project: dep.project,\n                        name: dep.name,\n                        path: dep.path,\n                        semver: (dep.semver || 'latest')\n                    };\n                    return ret;\n                });\n            }\n            if (def.releases) {\n                ret.releases = def.releases.map(function (rel) {\n                    var ret = {\n                        path: rel.path,\n                        semver: (rel.semver || null)\n                    };\n                    return ret;\n                });\n            }\n            return ret;\n        });\n    }).then(function (content) {\n        var ret = {\n            repo: api.context.config.repo,\n            ref: api.context.config.ref,\n            count: content.length,\n            time: new Date().toISOString()\n        };\n        ret.urls = {\n            def: 'https://github.com/' + ret.repo + '/blob/' + ret.ref + '/{path}'\n        };\n        ret.content = content;\n        return ret;\n    });\n}\nmodule.exports = getContent;\n"}